#Вразработке 
![](images/Pasted%20image%2020231031214315.png)
VIEWS - представляет собой виртуальную таблицу, которая не хранит непосредственно сами данные, а содержит запрос к базе данных. К вьюшке можно обращаться как к обычной таблице.


Практическое использование view


- Упрощают взаимодействие с базами данных. Можно заранее составить сложный по структуре запрос для создания представления и обращаться к нему при помощи простых запросов;
- Представления можно объединять с другими таблицами или представлениями;
- К представлениям можно обращаться из приложений;
- Скрытие реализации реальных таблицы (принцип инкапсуляции);
Синтаксис:
```
CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW имя [ ( имя_столбца [, ...] ) ]
    [ WITH ( имя_параметра_представления [= значение_параметра_представления] [, ... ] ) ]
    AS запрос
    [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
```

CREATE VIEW создаёт представление запроса. Создаваемое представление лишено физической материализации, поэтому указанный запрос будет выполняться при каждом обращении к представлению.

Команда CREATE OR REPLACE VIEW действует подобным образом, но если представление с этим именем уже существует, оно заменяется. Новый запрос должен выдавать те же столбцы, что выдавал запрос, ранее определённый для этого представления (то есть, столбцы с такими же именами должны иметь те же типы данных и следовать в том же порядке), но может добавить несколько новых столбцов в конце списка. Вычисления, в результате которых формируются столбцы представления, могут быть совершенно другими.

Если задано имя схемы (например, CREATE VIEW myschema.myview ...), представление создаётся в указанной схеме, в противном случае — в текущей. Временные представления существуют в специальной схеме, так что при создании таких представлений имя схемы задать нельзя. Имя представления должно отличаться от имён других представлений, таблиц, последовательностей, индексов или сторонних таблиц в этой схеме.


Параметры

TEMPORARY или TEMP

	С таким указанием представление создаётся как временное. Временные представления автоматически удаляются в конце сеанса. Существующее постоянное представление с тем же именем не будет видно в текущем сеансе, пока существует временное, однако к нему можно обратиться, дополнив имя указанием схемы.

	Если в определении представления задействованы временные таблицы, представление так же создаётся как временное (вне зависимости от присутствия явного указания TEMPORARY).

RECURSIVE

	Создаёт рекурсивное представление. Синтаксис

```
CREATE RECURSIVE VIEW [ схема . ] имя (имена_столбцов) AS SELECT ...;

```

	равнозначен

```
CREATE VIEW [ схема . ] имя AS WITH RECURSIVE имя (имена_столбцов) AS (SELECT ...) SELECT имена_столбцов FROM имя;

```

	Для рекурсивного представления обязательно должен задаваться список с именами столбцов.

имя

	Имя создаваемого представления (возможно, дополненное схемой).

имя_столбца

	Необязательный список имён, назначаемых столбцам представления. Если отсутствует, имена столбцов формируются из результатов запроса.

WITH ( имя_параметра_представления [= значение_параметра_представления] [, ... ] )

	В этом предложении могут задаваться следующие необязательные параметры представления:

check_option (string)

	Этот параметр может принимать значение local (локально) или cascaded (каскадно) и равнозначен указанию WITH [ CASCADED | LOCAL ] CHECK OPTION (см. ниже). Изменить этот параметр у существующего представления с помощью ALTER VIEW нельзя.

security_barrier (boolean)

	Этот параметр следует использовать, если представление должно обеспечивать защиту на уровне строк. За дополнительными подробностями обратитесь к Разделу 38.5.

запрос

	Команда SELECT или VALUES, которая выдаёт столбцы и строки представления.

WITH [ CASCADED | LOCAL ] CHECK OPTION

	Это указание управляет поведением автоматически изменяемых представлений. Если оно присутствует, при выполнении операций INSERT и UPDATE с этим представлением будет проверяться, удовлетворяют ли новые строки условию, определяющему представление (то есть, проверяется, будут ли новые строки видны через это представление). Если они не удовлетворяют условию, операция не будет выполнена. Если указание CHECK OPTION отсутствует, команды INSERT и UPDATE смогут создавать в этом представлении строки, которые не будут видны в нём. Поддерживаются следующие варианты проверки:

LOCAL

	Новые строки проверяются только по условиям, определённым непосредственно в самом представлении. Любые условия, определённые в нижележащих базовых представлениях, не проверяются (если только в них нет указания CHECK OPTION).

CASCADED

	Новые строки проверяются по условиям данного представления и всех нижележащих базовых. Если указано CHECK OPTION, а LOCAL и CASCADED опущено, подразумевается указание CASCADED.

	Указание CHECK OPTION нельзя использовать с рекурсивными представлениями.

	Заметьте, что CHECK OPTION поддерживается только для автоматически изменяемых представлений, не имеющих триггеров INSTEAD OF и правил INSTEAD. Если автоматически изменяемое представление определено поверх базового представления с триггерами INSTEAD OF, то для проверки ограничений автоматически изменяемого представления можно применить указание LOCAL CHECK OPTION, хотя условия базового представления с триггерами INSTEAD OF при этом проверяться не будут (каскадная проверка не будет спускаться к представлению, модифицируемому триггером, и любые параметры проверки, определённые для такого представления, будут просто игнорироваться). Если для представления или любого из его базовых отношений определено правило INSTEAD, приводящее к перезаписи команды INSERT или UPDATE, в перезаписанном запросе все параметры проверки будут игнорироваться, в том числе проверки автоматически изменяемых представлений, определённых поверх отношений с правилом INSTEAD.



материализованные представления



В принципе это просто - если view выполняет реальный запрос каждый раз, когда идет запрос к view. То материализованные представления просто пересчитываются вами раз в некоторое время и работают по сути как таблицы.

Это очень удобно, чтобы подхачить и быстро решить вопрос с производительностью, но такая view в случае роста данных будет пересчитываться все дольше и дольше, даже в режиме конкурентности.

Пересчитать тоже можно по сути только всё разом. Блокировки всякие возникают. Как по мне минусов больше, чем плюсов, но если тупит прям здесь и сейчас, то это выход и очень полезный инструмент.

Короче говоря, мы у себя от них отказались так же быстро, как и ввели ) Все перевели на таблицы - они дают боле ожидаемое поведение. Могут включаться в другие VIEW, если надо, и обновляются на сколько точечно, на сколько вы сделаете.

```
 CREATE MATERIALIZED VIEW MV_MY_VIEW
 [ WITH (storage_parameter [= value] [, ... ]) ]
    [ TABLESPACE tablespace_name ]
     AS SELECT * FROM <table_name>;
```

Для поддержания актуальности данных необходимо передически обновлять материализованное представление.
```
REFRESH MATERIALIZED VIEW mymatview;
```

нематериализованные представления

Нематериализованное представставление каждый раз при обращении к нему выполняет запрос, который его формирует. Таким образом нематериализованное представление не имеет физических данных в отличии от материализованных представлений.


пересчёт представлений

```
REFRESH MATERIALIZED VIEW [ CONCURRENTLY ] имя
    [ WITH [ NO ] DATA ]
```

REFRESH MATERIALIZED VIEW полностью заменяет содержимое материализованного представления. Эту команду разрешено выполнять только владельцам мат. представления. Старое его содержимое при этом аннулируется. Если добавлено указание WITH DATA (или нет никакого), нижележащий запрос выполняется и выдаёт новые данные, так что материализованное представление остаётся в сканируемом состоянии. Если указано WITH NO DATA, новые данные не выдаются, и оно оказывается в несканируемом состоянии.

Указать CONCURRENTLY вместе с WITH NO DATA нельзя.


Параметры

CONCURRENTLY

	Обновить материализованное представление, не блокируя параллельные выборки из него. Без данного параметра обновление, затрагивающее много строк, обычно задействует меньше ресурсов и выполнится быстрее, но может препятствовать чтению этого материализованного представления другими сеансами. При этом данный режим может быть быстрее при небольшом количестве строк.

	Данный параметр допускается, только если в материализованном представлении есть хотя бы один индекс UNIQUE, построенный только по именам столбцов и включающий все строки (то есть это не должен быть индекс по выражению или индекс, содержащий WHERE).

	Этот параметр нельзя использовать, когда материализованное представление ещё не наполнено.

	Даже с этим параметром в один момент времени допускается только одно обновление (REFRESH) материализованного представления.

имя

	Имя (возможно, дополненное схемой) материализованного представления, подлежащего обновлению.


Замечания

Тогда как индекс по умолчанию для операций CLUSTER команда REFRESH MATERIALIZED VIEW сохраняет, она не упорядочивает генерируемые строки по нему. Если генерируемые данные необходимо упорядочить, в определяющем запросе нужно явно указать ORDER BY.


Примеры

Эта команда заменяет содержимое материализованного представления order_summary, используя запрос из определения материализованного представления, и оставляет его в сканируемом состоянии:

```
REFRESH MATERIALIZED VIEW order_summary;
```
Эта команда освобождает пространство, связанное с материализованным представлением annual_statistics_basis, и оставляет это представление в несканируемом состоянии:

```
REFRESH MATERIALIZED VIEW annual_statistics_basis WITH NO DATA;
```

индексы

view не хранит никаких данных, а раз нет данных - то не по чему строить индекс.

Пример принципиальной проблемы индекса на view: если сделать view вида select foo, avg(bar) from tablename group by foo; - как пересчитывать данные при изменении строк в tablename?


Индекс может быть создан на материализованном представлении (materialized view) - потому что такое представление данные хранит непосредственно. Но обновлять эти данные требуется вручную запросом REFRESH MATERIALIZED VIEW, который выполнит запрос, запишет его результат в новый heap, затем заменит старый heap новым (если не указан concurrently) либо обновит несовпадающие строки (для concurrently)

Фишки


То, что будет написано далее не надо юзать каждый день, надо понимать зачем вы это делаете и понимать последствия! Однако, возможно, это спасет ваш проект в экстренной ситуации.

В PostgreSQL, а вы возможно уже знаете, что я очень люблю эту базу данных, есть очень крутая тема, которую надо использовать с осторожностью - INSERT, UPDATE триггеры на VIEW. Подробнее вы можете почитать в документации от Postgres Pro. Суть в том, что VIEW может вести себя как таблица, но не давая доступа в таблицу напрямую. Я считаю, что тут или автоматизированно надо этим управлять или очень редко использовать или вообще не соваться, чтобы "просто попробовать прикрутить к новой фиче на проде".

Поскольку VIEW - это запрос, то вместе с LATERAL JOIN можно делать прозрачный и оптимизированный вызов хранимых процедур.

Ограничения для delte,update во view

...

Особенности реализации в clickhouse

Создаёт представление. Представления бывают обычные, материализованные(MATERIALIZED) и LIVE.

Обычные представления

```
CREATE [OR REPLACE] VIEW [IF NOT EXISTS] [db.]table_name [ON CLUSTER] AS SELECT ...

```
Обычные представления не хранят никаких данных, они выполняют чтение данных из другой таблицы при каждом доступе. Другими словами, обычное представление — это не что иное, как сохраненный запрос. При чтении данных из представления этот сохраненный запрос используется как подзапрос в секции FROM.
Для примера, пусть вы создали представление:
```
CREATE VIEW view AS SELECT ...

```
и написали запрос:
```
SELECT a, b, c FROM view

```
Этот запрос полностью эквивалентен использованию подзапроса:
```
SELECT a, b, c FROM (SELECT ...)

```

Материализованные представления

```
CREATE MATERIALIZED VIEW [IF NOT EXISTS] [db.]table_name [ON CLUSTER] [TO[db.]name] [ENGINE = engine] [POPULATE] AS SELECT ...

```
Материализованные (MATERIALIZED) представления хранят данные, преобразованные соответствующим запросом SELECT.
При создании материализованного представления без использования TO [db].[table], нужно обязательно указать ENGINE- движок таблицы для хранения данных.
При создании материализованного представления с использованием TO [db].[table], нельзя указывать POPULATE.
Материализованное представление устроено следующим образом: при вставке данных в таблицу, указанную в SELECT-е, кусок вставляемых данных преобразуется этим запросом SELECT, и полученный результат вставляется в представление.
```
:::note "Важно"
Материализованные представления в ClickHouse используют **имена столбцов** вместо порядка следования столбцов при вставке в целевую таблицу. Если в результатах запроса `SELECT` некоторые имена столбцов отсутствуют, то ClickHouse использует значение по умолчанию, даже если столбец не является [Nullable](/docs/ru/sql-reference/data-types/nullable). Безопасной практикой при использовании материализованных представлений считается добавление псевдонимов для каждого столбца.
Материализованные представления в ClickHouse больше похожи на `after insert` триггеры. Если в запросе материализованного представления есть агрегирование, оно применяется только к вставляемому блоку записей. Любые изменения существующих данных исходной таблицы (например обновление, удаление, удаление раздела и т.д.) не изменяют материализованное представление.
:::

```
Если указано POPULATE, то при создании представления в него будут добавлены данные, уже содержащиеся в исходной таблице, как если бы был сделан запрос CREATE TABLE ... AS SELECT .... Если POPULATEне указано, представление будет содержать только данные, добавленные в таблицу после создания представления. Использовать POPULATEне рекомендуется, так как в представление не попадут данные, добавляемые в таблицу во время создания представления.
Запрос SELECTможет содержать DISTINCT, GROUP BY, ORDER BY, LIMIT… Следует иметь ввиду, что соответствующие преобразования будут выполняться независимо, на каждый блок вставляемых данных. Например, при наличии GROUP BY, данные будут агрегироваться при вставке, но только в рамках одной пачки вставляемых данных. Далее, данные не будут доагрегированы. Исключение - использование ENGINE, производящего агрегацию данных самостоятельно, например, SummingMergeTree.
Выполнение запросов ALTERнад материализованными представлениями имеет свои особенности, поэтому эти запросы могут быть неудобными для использования. Если материализованное представление использует конструкцию TO [db.]name, то можно выполнить DETACHпредставления, ALTERдля целевой таблицы и последующий ATTACHранее отсоединенного (DETACH) представления.
Обратите внимание, что работа материализованного представления находится под влиянием настройки optimize_on_insert. Перед вставкой данных в таблицу происходит их слияние.
Представления выглядят так же, как обычные таблицы. Например, они перечисляются в результате запроса SHOW TABLES.
Чтобы удалить представление, следует использовать DROP VIEW. Впрочем, DROP TABLEтоже работает для представлений.

LIVE-представления [экспериментальный функционал]

```
:::note "Важно"
Представления `LIVE VIEW` являются экспериментальной возможностью. Их использование может повлечь потерю совместимости в будущих версиях.
Чтобы использовать `LIVE VIEW` и запросы `WATCH`, включите настройку [allow_experimental_live_view](/docs/ru/operations/settings/settings#allow-experimental-live-view).
:::

```

```
CREATE LIVE VIEW [IF NOT EXISTS] [db.]table_name [WITH [TIMEOUT [value_in_sec] [AND]] [REFRESH [value_in_sec]]] AS SELECT ...

```
LIVE VIEW хранит результат запроса SELECT, указанного при создании, и обновляется сразу же при изменении этого результата. Конечный результат запроса и промежуточные данные, из которых формируется результат, хранятся в оперативной памяти, и это обеспечивает высокую скорость обработки для повторяющихся запросов. LIVE-представления могут отправлять push-уведомления при изменении результата исходного запроса SELECT. Для этого используйте запрос WATCH.
Изменение LIVE VIEW запускается при вставке данных в таблицу, указанную в исходном запросе SELECT.
LIVE-представления работают по тому же принципу, что и распределенные таблицы. Но вместо объединения отдельных частей данных с разных серверов, LIVE-представления объединяют уже имеющийся результат с новыми данными. Если в исходном запросе LIVE-представления есть вложенный подзапрос, его результаты не кешируются, в кеше хранится только результат основного запроса.

```
- [Табличные функции](/docs/ru/sql-reference/table-functions/) в основном запросе не поддерживаются.
- Таблицы, не поддерживающие изменение с помощью запроса `INSERT`, такие как [словари](/docs/ru/sql-reference/dictionaries/) и [системные таблицы](/docs/ru/operations/system-tables/), а также [нормальные представления](#normal) или [материализованные представления](#materialized), не запускают обновление LIVE-представления.
- В LIVE-представлениях могут использоваться только такие запросы, которые объединяют результаты по старым и новым данным. LIVE-представления не работают с запросами, требующими полного пересчета данных или агрегирования с сохранением состояния.
- `LIVE VIEW` не работает для реплицируемых и распределенных таблиц, добавление данных в которые происходит на разных узлах.
- `LIVE VIEW` не обновляется, если в исходном запросе используются несколько таблиц.

В случаях, когда `LIVE VIEW` не обновляется автоматически, чтобы обновлять его принудительно с заданной периодичностью, используйте [WITH REFRESH](#live-view-with-refresh).
```


Отслеживание изменений LIVE-представлений

Для отслеживания изменений LIVE-представления используйте запрос WATCH.
Пример:
```
CREATE TABLE mt (x Int8) Engine = MergeTree ORDER BY x;
CREATE LIVE VIEW lv AS SELECT sum(x) FROM mt;
```
Отслеживаем изменения LIVE-представления при вставке данных в исходную таблицу.
```
WATCH lv;

```

```
┌─sum(x)─┬─_version─┐
│      1 │        1 │
└────────┴──────────┘
┌─sum(x)─┬─_version─┐
│      3 │        2 │
└────────┴──────────┘
┌─sum(x)─┬─_version─┐
│      6 │        3 │
└────────┴──────────┘

```

```
INSERT INTO mt VALUES (1);
INSERT INTO mt VALUES (2);
INSERT INTO mt VALUES (3);

```
Для получения списка изменений используйте ключевое слово EVENTS.
```
WATCH lv EVENTS;

```

```
┌─version─┐
│       1 │
└─────────┘
┌─version─┐
│       2 │
└─────────┘
┌─version─┐
│       3 │
└─────────┘
...

```
Для работы с LIVE-представлениями, как и с любыми другими, можно использовать запросы SELECT. Если результат запроса кеширован, он будет возвращен немедленно, без обращения к исходным таблицам представления.
```
SELECT * FROM [db.]live_view WHERE ...
```
Для работы с LIVE-представлениями, как и с любыми другими, можно использовать запросы SELECT. Если результат запроса кеширован, он будет возвращен немедленно, без обращения к исходным таблицам представления.
```
SELECT * FROM [db.]live_view WHERE ...
```

Принудительное обновление LIVE-представлений

Чтобы принудительно обновить LIVE-представление, используйте запрос ALTER LIVE VIEW [db.]table_name REFRESH.

Секция WITH TIMEOUT

LIVE-представление, созданное с параметром WITH TIMEOUT, будет автоматически удалено через определенное количество секунд с момента предыдущего запроса WATCH, примененного к данному LIVE-представлению.
```
CREATE LIVE VIEW [db.]table_name WITH TIMEOUT [value_in_sec] AS SELECT ...

```
Если временной промежуток не указан, используется значение настройки temporary_live_view_timeout.
Пример:
```
CREATE TABLE mt (x Int8) Engine = MergeTree ORDER BY x;
CREATE LIVE VIEW lv WITH TIMEOUT 15 AS SELECT sum(x) FROM mt;

```

Секция WITH REFRESH

LIVE-представление, созданное с параметром WITH REFRESH, будет автоматически обновляться через указанные промежутки времени, начиная с момента последнего обновления.
```
CREATE LIVE VIEW [db.]table_name WITH REFRESH [value_in_sec] AS SELECT ...

```
Если значение временного промежутка не задано, используется значение periodic_live_view_refresh.
Пример:
```
CREATE LIVE VIEW lv WITH REFRESH 5 AS SELECT now();
WATCH lv;

```

```
┌───────────────now()─┬─_version─┐
│ 2021-02-21 08:47:05 │        1 │
└─────────────────────┴──────────┘
┌───────────────now()─┬─_version─┐
│ 2021-02-21 08:47:10 │        2 │
└─────────────────────┴──────────┘
┌───────────────now()─┬─_version─┐
│ 2021-02-21 08:47:15 │        3 │
└─────────────────────┴──────────┘

```
Параметры WITH TIMEOUTи WITH REFRESHможно сочетать с помощью AND.
```
CREATE LIVE VIEW [db.]table_name WITH TIMEOUT [value_in_sec] AND REFRESH [value_in_sec] AS SELECT ...

```
Пример:
```
CREATE LIVE VIEW lv WITH TIMEOUT 15 AND REFRESH 5 AS SELECT now();

```
По истечении 15 секунд представление будет автоматически удалено, если нет активного запроса WATCH.
```
WATCH lv;

```

```
Code: 60. DB::Exception: Received from localhost:9000. DB::Exception: Table default.lv doesn't exist..

```

Использование LIVE-представлений

Наиболее частые случаи использования LIVE-представлений:
- Получение push-уведомлений об изменениях данных без дополнительных периодических запросов.
- Кеширование результатов часто используемых запросов для получения их без задержки.
- Отслеживание изменений таблицы для запуска других запросов SELECT.
- Отслеживание показателей из системных таблиц с помощью периодических обновлений.