### JSON
1. **Вопрос**: Какой формат даты для JSON чаще всего используется?
    **Ответ**: в JSON чаще всего используется _ISO_ формат

2. **Вопрос**: Есть ли в JSON ограничение на уровень вложенности объектов?
    **Ответ**: В python по умолчанию ограничением является 100 вложений, однако его можно увеличить при помощи аргумента `dephs` в `json.dump`, `json.dumps`. Поэтому по сути - ограничения задаются либами для работы с JSON. У самого JSON такого ограничения нет.
    **Интересный факт**: пока проверял инфу - удалось создать dict с максимальной вложенностью (у меня ругалось на макс. вложенность при 1493 вложении)

3. **Вопрос**: Есть ли ограничения у JSON?
   **Ответ:** По сути все ограничения JSON связаны с железом, кроме типов данных. JSON не умеет сам работать с кастомными типами данных, с типом даты, UUID и т.д. Однако, все это обходится с помощью кастомных сериализаторов.

4. **Вопрос:** Какие есть библиотеки для работы с JSON?
   **Ответ:** json,
   orjson - для скоростной работы с json,
   tortillia - для обертки запроса api и превращения ответа в формат json 
   jsonpickle - позволяет сериализовать объекты в формат json
   jsondiff - нужен для поиска различий между json файлами

5. **Вопрос:** Pydantic и JSON:
   **Ответ:** На данный момент для анализа json данных используется `from_json` из `pydantic_core`. С помощью этой функции pydantic сам получает необходимые поля из json и анализирует их. Если в JSON есть список, а модель поддерживает только `tuple`, то pydantic автоматически приведет список к tuple. Эта функция принимает 2 аргумента (`value: str, allow_patrial: bool`)
   Первый аргумент - наш JSON, второй - флаг, который разрешает или запрещает использовать частичный JSON.
   >[!tip]+ Пример использования:
   >```python
   >from pydantic_core import from_json
   >from pydantic import BaseModel
   >
   >class Dog(BaseModel):
   >	breed: str
   >	name: str
   >	friends: list
   >	
   >partial_dog_json = '{"breed": "lab", "name": "fluffy", "friends": ["buddy", "spot", "rufus"], "age'
   >dog = Dog.model_validate(from_json(partial_dog_json, allow_partial=True))
   >print(repr(dog))
   >#> Dog(breed='lab', name='fluffy', friends=['buddy', 'spot', 'rufus'])
   >```

6. **Вопрос:** Где используется JSON?
   **Ответ:** По большей части JSON используется для обмена данных между сервисами (особенно в API), но вообще его можно использовать почти где угодно. Даже для хранения данных в БД.

7. **Вопрос:** что такое JSONPath?
   **Ответ:** JSONPath - это язык запросов, аналогичный XPath. Для работы с JSONPath в Python используют `jsonpath-ng` библиотеку.

8. **Вопрос:** Работа с JSON в postgresql. Тип данных, операции jsonpath
   **Ответ:** для работы с JSON и JSONB в opstgresql используется:
   - `jsonb_path_exists`(value, jsonpath) - содержится ли шаблон в json
   - `jsonb_path_match`(value, jsonpath) - выполняет поиск значений, которые соответствуют шаблону jsonpath
   - `jsonb_path_query`(value, jsonpath) - используется для запросов к json с использованием jsonpath (*основная операция для работы с jsonpath*)
   - `jsonb_path_query_array`(value, jsonpath) - возвращает массив значений, соответствующих шаблону jsonpath
   - `jsonb_path_query_first`(value, jsonpath) - возвращает первое значение, соответствующее шаблону jsonpath
   основные операции в jsonpath:
   `$` - Это текущий контекст json элемента. То есть по сути - при помощи этой операции мы обозначаем область для обработки json.
   `?` - Позволяет указать фильтр (эта операция аналогична `WHERE`)
   `@` - Текущий контекст в выражении фильтра. То есть сначала мы указываем область обработки при помощи `$`, а далее уже используем `@` для фильтрации:
   Пример: `$[*] ? (@ > 3)`
   `[]` - обозначение массива
   `*` - знак, обозначающий любой элемент

9. **Вопрос:** Когда JSON нужно использовать в БД?
   **Ответ:** JSON используют в бд тогда, когда сигнатура хранимых данных постоянно меняется. Соответственно, вместо того, что бы постоянно менять структуру таблицы - проще хранить данные в формате JSON, где не важно, какой структуры данные там хранятся.

### XML
1. **Вопрос:** Что такое XML? Где он используется? Чем он отличается от JSON? Чем он хуже JSON?
   **Ответ:** XML - тоже язык текстовой разметки. Ранее использовался почти везде, но позже все перешли на JSON, так как его удобнее читать + он меньше весит за счет более компактного синтаксиса.
   На данный момент он часто используется в 1С + его можно встретить при работе с excel файлами.

2. **Вопрос:** библиотеки для работы с XML
   **Ответ:** lxml, xml, defusedxml (проверяет xml на безопасность)

3. **Вопрос:** Что такое XPATH?
   **Ответ:** XPath - это язык запросов, необходимый для поиска данных внутри XML

4. **Вопрос:** Кейсы использования XPath для python разработчика
   **Ответ:** Основным кейсом для использования XPath является парсинг данных. Как в явном виде - так и в неявном(используя либы по типу `BeautifulSoup`).

### YAML
1. **Вопрос:** Можно ли писать в YAML в стиле JSON?
   **Ответ:** Да можно. В YAML файле можно все написать на JSON.

2. **Вопрос:** Что такое якоря в YAML?
   **Ответ:** Якоря в YAML - это ссылки на существующие сущности, которые можно переиспользовать. Объявляется якорь через `<поле>: &<название якоря>`, а использовать его можно через `<<: *<название якоря>`.

3. **Вопрос:** Где применяется YAML?
   **Ответ:** YAML применяется в SWAGGER, конфигурациях, манифестах.

4. **Вопрос:** Методы для сериализации YAML
   **Ответ:** метод dump в yaml сам сериализует объекты (а точнее их поля) в yaml. Это работает даже в том случае, если поле объекта является объектом.
   При такой сериализации тэг в YAML документе будет иметь следующий вид: `python/object:__main__.Person`, однако этот тэг можно поменять следующим образом:
   >[!code]+
   >```python
   >class Person(yaml.YAMLObject):
   >	yaml_tag = "Person"
   >	...
   >```
   
   в этом случае тэг в YAML документе будет иметь значение свойства `yaml_tag`.
   Для сериализации используется `safe_load`:
   >[!code]+
   >```python
   >person = yaml.safe_load(yaml_obj, Loader=yaml.Loader)
   >```


5. **Вопрос:** Опасный метод load. Почему от него отказались?
   **Ответ:** От метода load отказались, так как в нем можно было передавать исполняемый код, что создавало серьезную уязвимость. Сейчас же вместо `load` используют `safe_load`, который не позволяет передавать в себе исполняемый код.