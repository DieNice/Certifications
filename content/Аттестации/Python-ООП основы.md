---
tags:
  - OOP
  - Usefull
  - Python
---
%%  %%# Теория

1. Что такое объект (класс)?
2. Для чего нужно ООП?
3. Назвать 3 кита ООП и описать, в чем заключается суть каждого.
4. Рассказать про отношения IS-A, HAS-A (ассоциацию, композицию, агрегацию).
5. Рассказать, какие есть магические методы и для чего они могут использоваться.
6. Рассказать что такое self и для чего он нужен.
7. Что такое абстрактный класс?
8. Рассказать про разницу между абстрактным классом и интерфейсом.
9. Рассказать про ключевое слово super.
10. Что такое staticmethod и classmethod? Объяснить в чем разница.
11. Рассказать про множественное наследование.
12. Переопределение методов

**Дополнительные вопросы к аттестации «Python: ООП основы»**

1. Как обозначают приватные методы, свойства объекта? Можно ли до них достучаться? Как это сделать?
2. Что такое утиная типизация?
3. Что такое структурная типизация, номинальная типизация? Что такое Protocol? Чем отличается от Абстрактного класса
4. Что такое __slots__?

**Краткие ответы к аттестации «Python: ООП основы»**

1. Объект(класс) – это абстрактная сущность описывающая структуру нового типа данных в проекте. Эта сущность может описывать предмет реальной жизни, абстрактную сущность в проекте и т.п.
2. Основной задачей ООП является описание собственных типов данных для ускорения процесса написания кода, улучшения читабельности кода, улучшения структуры проекта за счет умеренного повышения уровня абстракции используемых сущностей (абстракция всегда должна быть в меру т.к. повышенный уровень абстракции может свести на нет все плюсы от ООП).
3. Инкапсуляция – заключается в сокрытии внутренней реализации класса. Т.е. должна быть возможность использовать объект без знания о том, что содержится внутри этого объекта. Ярким примером являются приватные и защищенные методы и поля класса.
    

Наследование – заключается в наследовании полей и методов родительского класса, что помогает переиспользовать уже написанный код, безопасно изменять код и т.п.

Полиморфизм – это способность объекта использовать методы произвольного класса, причем не важно, как эти объекты устроены внутри. Источник[^1][^2][^4]

4.    Отношение IS-A описывает связь «Является ли класс подвидом другого». Иными словами, отношение IS-A есть другое название наследования.
HAS-A:

Ассоциация – это тот случай, когда один класс включает в себя другой класс в качестве поля.

Агрегация – это частный случай ассоциации. Суть агрегации заключается в том, что класс, содержащий в себе объект и объект, содержимый внутри другого класса – независимые друг от друга объекты. Т.е. при удалении содержащего класса – содержимый все еще продолжит свое существование.

Композиция – это частный случай ассоциации. Связь содержащего и содержимого объектов является более тесной в сравнении с агрегацией. Т.е. при удалении содержащего объекта – содержимый также прекращает свое существование. Источники: [^3]

5. Основные магические методы:

__init__ – конструктор класса

__eq__ – переопределение оператора ==

__ne__ – переопределение оператора !=

__lt__ – переопределение оператора <

__gt__ – переопределение оператора >

__le__ – переопределение оператора <=

__ge__ – переопределение оператора >=

__getitem__ – определяет вызов вида obj[key]

И т.д. Источники: 

6. self – это первый аргумент обычных методов класса. Ссылкой на экземпляр класса. При вызове метода класса – на самом деле вызывается конструкция вида myObj: myType myType.method(myObj, аргументы) Источники[^1]

7. Абстрактный класс – это объект, описывающий методы и поля своих потомков. Может содержать в себе частичную реализацию объявленных потомков. Основная его задача – быть отнаследованным от другого класса. В python основным инструментом абстракции является библиотека abc. Источники [^5]
8. Основным отличием интерфейса от абстрактного класса является то, что абстрактный класс может частично реализовывать методы потомков, в то время как интерфейс описывает только структуру своих потомков. Также все методы интерфейса должны быть обязательно реализованы внутри своих потомков. Источники: [^5]
9. Ключевое слово super – является ссылкой на родительский класс. Предназначен для того, чтобы обращаться к методам родительского класса. Источники: [^1][^2]
10. staticmethod – это обычная функция, но объявленная внутри объекта (т.е. такой функции совсем не обязательно передавать в качестве первого аргумента ссылку на экземпляр класса)
    

сlassmethod – эта функция, принимающая в качестве первого аргумента сам класс. Может использоваться для объявления альтернативного конструктора класса. Источники: [^2][^5]


**Краткие ответы к дополнительным вопросам по аттестации «Python: ООП основы»**

1. Приватные методы и поля объявляются через два нижних подчеркивания перед названием метода или поля. До них можно достучаться следующим способом:
	myObj.myClass__field. [^1][^2].
1. Утиная типизация – работает по принципу «Если что-то выглядит как утка, плавает как утка, крякает как утка, то, скорее всего, это утка». Иными словами – если какой-либо экземпляр ведет себя как определенный объект – то скорее всего – этот этот объект.
В пример можно привести строку и список. Пусть это и разные типы данных, однако ведут они себя схожим образом при обращении к конструкции stroka[key], spisok[key]. Источники: [^2]
1. __slots__ Используется для оптимизации класса. При объявлении этого магического метода – в нем указываются все поля и методы класса, которые будут использоваться. Крайне не рекомендуется использовать в качестве полей изменяемые типы данных, т.к. все преимущества __slots__ могут свестись на нет. Источники: [^2]

----
# Практика

## Задача 1

Написать реализацию классов котопса и псакота.  
```Python
class Cat():  
   def say(self,times):  
      print('Meow '*times)
class Dog():  
   def say(self,times):  
      print('Bow-Wow '*times)
class CatDog(Cat,Dog):  
   pass  
  
class DogCat(Dog,Cat):  
   pass
  
muteDog=CatDog()  
muteDog.say(3)       #Meow Meow Meow  
  
muteCat=DogCat()  
muteCat.say(2)       #Bow-Wow Bow-Wow
```


## Задача 2

Реализуйте структуру данных, представляющую собой расширенную структуру стек. Необходимо поддерживать добавление элемента на вершину стека, удаление с вершины стека, и необходимо поддерживать операции сложения, вычитания, умножения и целочисленного деления.

Операция сложения на сте
ке определяется следующим образом. Со стека снимается верхний элемент (**top1**), затем снимается следующий верхний элемент (**top2**), и затем как результат операции сложения на вершину стека кладется элемент, равный **top1 + top2**.

Аналогичным образом определяются операции вычитания (**top1 - top2)**, умножения (**top1 * top2**) и целочисленного деления (**top1 // top2**).

Реализуйте эту структуру данных как класс **ExtendedStack**, отнаследовав его от стандартного класса **list**.  
Требуемая структура класса:

```Python
class ExtendedStack(list):
    def sum(self):
        # операция сложения

    def sub(self):
        # операция вычитания

    def mul(self):
        # операция умножения

    def div(self):
        # операция целочисленного деления
```

**Примечание** Для добавления элемента на стек используется метод **append**, а для снятия со стека – метод **pop**. Гарантируется, что операции будут совершаться только когда в стеке есть хотя бы два элемента.

## Задача 3

Реализовать класс песни для работы с музыкальной коллекцией. Каждая песня определяется артистом и её названием. Также каждой песне можно присваивает неограниченное число тэгов.

```Python

class Song:
	def __init__(self, artist, song):
		pass

	def add_tags(self , *args):
		pass
```

Пример работы с классом:

```Python
song_1 = Song("Соловей" , "Йорш")
song_1.add_tags("Панк-рок","Русский рок")

song_2 = Song("Money", "Ленинград")
song_2.add_tags("Поп-музыка","Фолк","ска-панк")
```

## Задача 4

Вам дается последовательность целых чисел и вам нужно ее обработать и вывести на экран сумму первой пятерки чисел из этой последовательности, затем сумму второй пятерки, и т. д.

Но последовательность не дается вам сразу целиком. С течением времени к вам поступают её последовательные части. Например, сначала первые три элемента, потом следующие шесть, потом следующие два и т. д.

Реализуйте класс **Buffer**, который будет накапливать в себе элементы последовательности и выводить сумму пятерок последовательных элементов по мере их накопления.

Одним из требований к классу является то, что он не должен хранить в себе больше элементов, чем ему действительно необходимо, т. е. он не должен хранить элементы, которые уже вошли в пятерку, для которой была выведена сумма.

Класс должен иметь следующий вид

```Python
class Buffer:
    def __init__(self):
        # конструктор без аргументов
    
    def add(self, *a):
        # добавить следующую часть последовательности
    def get_current_part(self):
        # вернуть сохраненные в текущий момент элементы последовательности в порядке, в котором они были     
        # добавлены
```
Пример работы с классом
```Python
buf = Buffer()
buf.add(1, 2, 3)
buf.get_current_part() # вернуть [1, 2, 3]
buf.add(4, 5, 6) # print(15) – вывод суммы первой пятерки элементов
buf.get_current_part() # вернуть [6]
buf.add(7, 8, 9, 10) # print(40) – вывод суммы второй пятерки элементов
buf.get_current_part() # вернуть []
buf.add(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) # print(5), print(5) – вывод сумм третьей и четвертой пятерки
buf.get_current_part() # вернуть [1]
```
## Задача 5

Вы создаете приключенческую игру. Структурой данных для инвентаря игрока должен быть словарь, в котором ключи - это строковые значения (названия предметов), а значения - количество имеющихся единиц.

> [!example] Пример {"веревка":1, "золотая монета": 42, "кинжал": 1, "фонарь": 6}

Представьте , что добыча побежденного дракона представлена в виде списка строк наподобие следующего:

```
dragon_loot = ["золотая монета", "кинжал", "золотая монета", "золотая монета","рубин"]
```

Напишите функцию add_to_inventory(inventory, added_items), в которой первый параметр - это словарь представляющий инвентарь игрока, а второй параметр это список. Функция должна возвращать словарь представляющий собой обновленный инвентарь. Обратите внимание что один и тот же элемент может встречаться несколько раз.

```
def add_to_inventory(inventory, added_items):
	# Сюда должен быть вставлен ваш код

inv = {"золотая монета": 42, "веревка": 1}
dragon_loot = ["золотая монета", "кинжал", "золотая монета", "золотая монета","рубин"]
inv = add_to_inventory(inv, dragon_loot)
print(inv)
```

1 часть. Напишите реализацию задачи при помощи функций.
2 часть. Напишите реализацию задачи при помощи ООП (каждый объект задачи должен быть классом)
3 часть. По своему усмотрению расширьте функционал и возможности приключенческой игры.

**Источники**

[^1]: [Простой Python](https://ecosystem.dns-shop.ru/upload/iblock/0ce/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B9%20Python.pdf).
[^2]:  Python к вершинам мастерства. Лучано Рамальо.
4[^3]:  [Агрегация и композиция](https://www.geeksforgeeks.org/python-oops-aggregation-and-composition/).
[^4]:  [Polymorphism in Python](https://www.geeksforgeeks.org/polymorphism-in-python/)
[^5]: [Использование интерфейсов и протоклов](https://to.digital/typed-python/weather/interfaces.html)