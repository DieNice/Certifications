# Подзапросы Lateral
Перед подзапросами в предложении **FROM** можно добавить ключевое слово **LATERAL**. Это позволит ссылаться в них на столбцы предшествующих элементов списка **FROM**. (Без **LATERAL** каждый подзапрос выполняется независимо и поэтому не может обращаться к другим элементам **FROM**.)
Перед табличными функциями в предложении **FROM** также можно указать **LATERAL**, но для них это ключевое слово необязательно; в аргументах функций в любом случае можно обращаться к столбцам в предыдущих элементах **FROM**.
Перед табличными функциями в предложении **FROM** также можно указать **LATERAL**, но для них это ключевое слово необязательно; в аргументах функций в любом случае можно обращаться к столбцам в предыдущих элементах **FROM**.
Элемент **LATERAL** может находиться на верхнем уровне списка **FROM** или в дереве **JOIN**. В последнем случае он может также ссылаться на любые элементы в левой части **JOIN**, справа от которого он находится.
Когда элемент **FROM** содержит ссылки **LATERAL**, запрос выполняется следующим образом: сначала для строки элемента **FROM** с целевыми столбцами, или набора строк из нескольких элементов FROM, содержащих целевые столбцы, вычисляется элемент LATERAL со значениями этих столбцов. Затем результирующие строки обычным образом соединяются со строками, из которых они были вычислены. Эта процедура повторяется для всех строк исходных таблиц.
Применять **LATERAL** имеет смысл в основном, когда для вычисления соединяемых строк необходимо обратиться к столбцам других таблиц. В частности, это полезно, когда нужно передать значение функции, возвращающей набор данных.
Например, если предположить, что vertices(polygon) возвращает набор вершин многоугольника, близкие вершины многоугольников из таблицы polygons можно получить так:  
```sql
SELECT p1.id, p2.id, v1, v2  
FROM polygons p1, polygons p2,  
LATERAL vertices(p1.poly) v1,  
LATERAL vertices(p2.poly) v2  
WHERE (v1 <-> v2) < 10 AND p1.id != p2.id;  
```
Этот запрос можно записать и так:  
```sql
SELECT p1.id, p2.id, v1, v2  
FROM polygons p1 CROSS JOIN LATERAL vertices(p1.poly) v1,  
polygons p2 CROSS JOIN LATERAL vertices(p2.poly) v2  
WHERE (v1 <-> v2) < 10 AND p1.id != p2.id;  
```
или переформулировать другими способами. (Как уже упоминалось, в данном примере ключевое  
слово LATERAL не требуется, но мы добавили его для ясности.)

```sql
SELECT name, child FROM nodes, LATERAL listchildren(name) AS child;  

name | child  
--------+-----------  
Top | Child1  
Top | Child2  
Top | Child3  
Child1 | SubChild1  
Child1 | SubChild2  
(5 rows)  
```
В этом примере не делается ничего такого, что мы не могли бы сделать, применив простое соединение, но для более сложных вычислений возможность поместить некоторую логику в функцию может быть весьма удобной.
# Lateral

Ключевое слово **LATERAL** может предварять вложенный запрос **SELECT** в списке **FROM**. Оно позволяет обращаться в этом вложенном **SELECT** к столбцам элементов **FROM**, предшествующим ему в списке **FROM**. (Без LATERAL все вложенные подзапросы **SELECT** обрабатываются независимо и не могут ссылаться на другие элементы списка **FROM**.)

Слово **LATERAL** можно также добавить перед вызовом функции в списке **FROM**, но в этом случае оно будет избыточным, так как выражения с функциями могут ссылаться на предыдущие элементы списка **FROM** в любом случае.
Элемент **LATERAL** может находиться на верхнем уровне списка **FROM** или в дереве **JOIN**. В последнем случае он может также ссылаться на любые элементы в левой части **JOIN**, справа от которого он находится.

Когда элемент **FROM** содержит ссылки **LATERAL**, запрос выполняется следующим образом: сначала для строки элемента **FROM** с целевыми столбцами, или набора строк из нескольких элементов **FROM**, содержащих целевые столбцы, вычисляется элемент **LATERAL** со значениями этих столбцов. Затем результирующие строки обычным образом соединяются со строками, из которых они были вычислены. Эта процедура повторяется для всех строк исходных таблиц.
Таблица, служащая источником столбцов, должна быть связана с элементом **LATERAL** соединением **INNER** или **LEFT**, в противном случае не образуется однозначно определяемый набор строк, из которого можно будет получать наборы строк для элемента **LATERAL**. Таким образом, хотя конструкция **X RIGHT JOIN LATERAL Y** синтаксически правильная, **Y** в ней не может обращаться к **X**.


В этом примере используется LATERAL для применения функции *get_product_names()*, возвращающей множество, для каждой строки таблицы manufacturers: 
```sql
SELECT m.name AS mname, pname  FROM manufacturers m, LATERAL get_product_names(m.id) pname;
```

Производители, с которыми в данный момент не связаны никакие продукты, не попадут в результат, так как это внутреннее соединение. Если бы мы захотели включить названия и этих производителей, мы могли бы сделать так:  
```sql
SELECT m.name  
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true  
WHERE pname IS NULL;
```

# Дополнительные примеры

```sql
SELECT *
 FROM laptop L1
 CROSS LATERAL
 (SELECT MAX(price) max_price, MIN(price) min_price  FROM Laptop L2
JOIN  Product P1 ON L2.model=P1.model 
WHERE maker = (SELECT maker FROM Product P2 WHERE P2.model= L1.model)) X;
```

# Ссылки

1. http://sql-tutorial.ru/ru/book_cross_apply/page2.html
2. Документация Postgresql 16.1 7.2.1.5 Подзапросы Lateral 