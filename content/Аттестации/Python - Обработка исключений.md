---
date: 2024-05-06
author: Проскурин Д.А
tags:
  - Аттестация
  - Python
---
>[!question] Что такое исключение? Для чего необходимы обработчики исключений? Конструкция исключений
>Исключение – класс, который возвращает …. . Обработчики исключений позволяют перехватить потенциальные ошибки. Использование данной конструкции не избавляет от ошибки, а позволяет узнать, в каком месте и при каких обстоятельствах она произошла.
>**try:**
>       исполняем какой-то код
>**except** Exception as e: #можно написать обработку для нескольких типов стразу
>	    обработка исключения
>**else:**
>	    код, который будет исполнен в случае, когда не возникает исключения
  **finally:**
 код, который гарантированно будет исполнен последним (всегда исполняется)
    
> [!question] Как поведет себя код, если обработать и не обработать исключение?
>  Если не обработать исключение программа завершит свое выполнение с ошибкой. Если ошибка обработана при помощи исключения, тогда пользователю выведется то, что написано в блоке except и программа продолжит работу дальше.

> [!question] Что произойдет, если использовать блок except без аргументов?
>  Обработка исключения будет более общей. Лучше использовать отдельные обработчики для разных исключений.

> [!question] Как задать псевдоним исключению?
>  except тип_исключения as имя

> [!question] Сколько может быть в водном обработчике блоков except? Какой приоритет у блоков except?
>  Любое количество. Блоки except выполняются по порядку

> [!question] Как создать свое собственное исключение?
>  class MyException(Exception):
  pass

> [!question] Как вызвать исключение? 
>  Raise

> [!question] Как будет выполняться блок finally?
>  Блок будет выполнен в любом случае, произошло исключение или нет.

> [!question] Что такое группа исключений, зачем нужна
>  Блок будет выполнен в любом случае, произошло исключение или нет.

> [!question] Как обрабатывать разные исключения которые могут быть в одном и том же участке кода, разной логикой. Напиши пример такой конструкции
>  Написать несколько блоков except для разных исключений

> [!question] Как отлавливать сразу несколько разных исключений в блоке кода. Напишите пример
>  Поставить в аргументы сразу несколько исключений, так они будут обрабатываться одной логикой

> [!question] Какие встроенные исключения вы знаете? Перечислите некоторые из них и для чего они нужны.
>  BaseException - базовое исключение, от которого берут начало все остальные.
SystemExit - исключение, порождаемое функцией sys.exit при выходе из программы.
KeyboardInterrupt - порождается при прерывании программы пользователем (обычно сочетанием клавиш Ctrl+C).
GeneratorExit - порождается при вызове метода close объекта generator.
Exception - а вот тут уже заканчиваются полностью системные исключения (которые лучше не трогать) и начинаются обыкновенные, с которыми можно работать.
StopIteration - порождается встроенной функцией next, если в итераторе больше нет элементов.
ArithmeticError - арифметическая ошибка.
FloatingPointError - порождается при неудачном выполнении операции с плавающей запятой. На практике встречается нечасто.
OverflowError - возникает, когда результат арифметической операции слишком велик для представления. Не появляется при обычной работе с целыми числами (так как python поддерживает длинные числа), но может возникать в некоторых других случаях.
ZeroDivisionError - деление на ноль.
AssertionError - выражение в функции assert ложно.
AttributeError - объект не имеет данного атрибута (значения или метода).
BufferError - операция, связанная с буфером, не может быть выполнена.
EOFError - функция наткнулась на конец файла и не смогла прочитать то, что хотела.
ImportError - не удалось импортирование модуля или его атрибута.
LookupError - некорректный индекс или ключ.
IndexError - индекс не входит в диапазон элементов.
KeyError - несуществующий ключ (в словаре, множестве или другом объекте).
MemoryError - недостаточно памяти.
NameError - не найдено переменной с таким именем.
UnboundLocalError - сделана ссылка на локальную переменную в функции, но переменная не определена ранее.
OSError - ошибка, связанная с системой.
BlockingIOError
ChildProcessError - неудача при операции с дочерним процессом.
ConnectionError - базовый класс для исключений, связанных с подключениями.
BrokenPipeError
ConnectionAbortedError
ConnectionRefusedError
ConnectionResetError
FileExistsError - попытка создания файла или директории, которая уже существует.
FileNotFoundError - файл или директория не существует.
InterruptedError - системный вызов прерван входящим сигналом.
IsADirectoryError - ожидался файл, но это директория.
NotADirectoryError - ожидалась директория, но это файл.
PermissionError - не хватает прав доступа.
ProcessLookupError - указанного процесса не существует.
TimeoutError - закончилось время ожидания.
ReferenceError - попытка доступа к атрибуту со слабой ссылкой.
RuntimeError - возникает, когда исключение не попадает ни под одну из других категорий.
NotImplementedError - возникает, когда абстрактные методы класса требуют переопределения в дочерних классах.
SyntaxError - синтаксическая ошибка.
IndentationError - неправильные отступы.
TabError - смешивание в отступах табуляции и пробелов.
SystemError - внутренняя ошибка.
TypeError - операция применена к объекту несоответствующего типа.
ValueError - функция получает аргумент правильного типа, но некорректного значения.
UnicodeError - ошибка, связанная с кодированием / раскодированием unicode в строках.
UnicodeEncodeError - исключение, связанное с кодированием unicode.
UnicodeDecodeError - исключение, связанное с декодированием unicode.
UnicodeTranslateError - исключение, связанное с переводом unicode.
Warning - предупреждение.

Задача для решения
Приведите пример своего исключения, если индекс вышел за рамки list

напишите исключение, которое обрабатывает отсутствие файла в каталоге
```python
try:
    # Строка кода, генерирующая исключение
except FileNotFoundError as e:
        print("Файл отсутствует, хотя должен был быть на месте!")
```

напишите обработку исключений для деления двух чисел и неверного заполнения реквизитов
```python
try:
    a = float(input("Введите делимое: "))
    b = float(input("Введите делитель: "))
    c = a / b
    print("Частное: %.2f" % c)
except ValueError:
    print("Нельзя вводить строки")
except ZeroDivisionError:
    print("Нельзя делить на ноль")
```

>[!question] Что такое группа исключений? Зачем нужна
>Бывают ситуации, когда необходимо сообщить о нескольких произошедших исключениях. Это часто случается в средах параллелизма, когда несколько задач могут завершиться неудачей параллельно, но есть и другие случаи использования, когда желательно продолжить выполнение и собрать несколько ошибок, а не вызывать первое исключение.
>Встроенный ExceptionGroup оборачивает список экземпляров исключений, чтобы их можно было вызывать вместе. Это само по себе исключение, поэтому его можно перехватить, как и любое другое исключение.

```python
def f():
...     excs = [OSError('error 1'), SystemError('error 2')]
...     raise ExceptionGroup('there were problems', excs)
...
>>> f()
  + Exception Group Traceback (most recent call last):
  |   File "<stdin>", line 1, in <module>
  |   File "<stdin>", line 3, in f
  | ExceptionGroup: there were problems
  +-+---------------- 1 ----------------
    | OSError: error 1
    +---------------- 2 ----------------
    | SystemError: error 2
    +------------------------------------
>>> try:
...     f()
... except Exception as e:
...     print(f'caught {type(e)}: e')
...
caught <class 'ExceptionGroup'>: e
>>>
```

>[!question] Что такое except *
>Используя `except*` вместо except, мы можем выборочно обрабатывать только те исключения в группе, которые соответствуют определенному типу. В следующем примере, показывающем вложенную группу исключений, каждое предложение исключений* извлекается из групповых исключений определенного типа, позволяя всем остальным исключениям распространяться на другие предложения и в конечном итоге вызываться повторно.
```python
def f():
...     raise ExceptionGroup(
...         "group1",
...         [
...             OSError(1),
...             SystemError(2),
...             ExceptionGroup(
...                 "group2",
...                 [
...                     OSError(3),
...                     RecursionError(4)
...                 ]
...             )
...         ]
...     )
...
>>> try:
...     f()
... except* OSError as e:
...     print("There were OSErrors")
... except* SystemError as e:
...     print("There were SystemErrors")
...
There were OSErrors
There were SystemErrors
  + Exception Group Traceback (most recent call last):
  |   File "<stdin>", line 2, in <module>
  |   File "<stdin>", line 2, in f
  | ExceptionGroup: group1
  +-+---------------- 1 ----------------
    | ExceptionGroup: group2
    +-+---------------- 1 ----------------
      | RecursionError: 4
      +------------------------------------
>>>
```


>[!question] Как добавить дополнительную информацию к исключению в traceback?
```python
try:
...     raise TypeError('bad type')
... except Exception as e:
...     e.add_note('Add some information')
...     e.add_note('Add some more information')
...     raise
...
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
TypeError: bad type
Add some information
Add some more information
>>>
```

# Материалы для подготовки к обработчика исключений
https://docs.python.org/3/tutorial/errors.html
https://ecosystem.dns-shop.ru/library/1551954/
https://education.yandex.ru/handbook/python/article/model-isklyuchenij-python-try-except-else-finally-moduli
https://ru.hexlet.io/courses/advanced_python/lessons/python_exceptions/theory_unit#sobstvennye-isklyucheniya