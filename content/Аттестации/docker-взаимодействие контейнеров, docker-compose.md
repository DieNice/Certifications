  
![](images/Pasted%20image%2020231031212348.png)
## **Использование папок хоста**

Контейнеры Docker по своей природе неизменяемы. Это означает, что при перезапуске контейнера все данные, сохраненные в нем, сотрутся. Но сохранить эти данные можно. Для этого Docker предоставляет возможность подключения к контейнеру локальных директорий.

Команда `docker run` сперва создает доступный для записи слой контейнера поверх указанного образа, а затем запускает его с использованием указанной команды.

Параметр `-v` или `--volume` (англ. volume — «том») позволяет монтировать локальные директории и файлы к контейнеру. Например, вы можете запустить базу данных MySQL и примонтировать директорию для хранения в ней настоящих данных.

$ docker run --name mysql-db -v $(pwd)/datadir:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:8.0.28-debian

##   

Подключение директории означает двустороннюю синхронизацию. Любой файл, измененный на хосте, изменится и в контейнере, а любой файл, измененный в контейнере, изменится и на хосте. Таким образом, если вы остановите и заново запустите базу данных, вы сможете примонтировать ту же директорию, и вам будут доступны ваши настройки и сохраненные данные.

  

Преимущество этого метода в том, что он прост и легок в использовании. Монтируйте локальные директории при помощи `docker run -v` тогда, когда планируете просматривать и изменять файлы на хосте. Например, это подходит для файлов конфигурации и логов.

  

## **Сохранение изменений при помощи томов Docker**

Для сохранения изменений можно монтировать не локальную директорию, а том Docker.

  

Том Docker — это директория где-то в вашей папке-хранилище Docker, которую можно примонтировать к одному или нескольким контейнерам. Тома управляются Docker и не зависят от специфики операционной системы.

  

# создать том (volume)

docker volume create mysql-data

  

# запустить контейнер mysql в фоне

$ docker run --name mysql-db -v mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:latest

  

# остановить контейнер mysql

docker rm -f mysql-db

  

# удалить том

docker volume remove mysql-data


Этот способ сохранения данных рекомендуется для случаев, когда вам не нужно заглядывать в файлы или изменять их на вашем хосте. По сравнению с привязыванием локальной директории привязывание тома более производительно.

# **Настройка внутренней сети Docker**

Сеть Docker построена на Container Network Model (CNM), которая позволяет кому угодно создать свой собственный сетевой драйвер. Таким образом, у контейнеров есть доступ к разным типам сетей и они могут подключаться к нескольким сетям одновременно. Помимо различных сторонних сетевых драйверов, у самого Docker-а есть 4 встроенных:

- **Bridge**: в этой сети контейнеры запускаются по умолчанию. Связь устанавливается через bridge-интерфейс на хосте. У контейнеров, которые используют одинаковую сеть, есть своя собственная подсеть, и они могут передавать данные друг другу по умолчанию.
    
- **Host**: этот драйвер дает контейнеру доступ к собственному пространству хоста (контейнер будет видеть и использовать тот же интерфейс, что и хост).
    
- **Macvlan**: этот драйвер дает контейнерам прямой доступ к интерфейсу и суб-интерфейсу (vlan) хоста. Также он разрешает транкинг.
    
- **Overlay**: этот драйвер позволяет строить сети на нескольких хостах с Docker (обычно на Docker Swarm кластере). У контейнеров также есть свои адреса сети и подсети, и они могут напрямую обмениваться данными, даже если они располагаются физически на разных хостах.
    

Сетевые драйвера Bridge и Overlay, возможно, используются чаще всего, поэтому в этой статье я буду больше уделять им внимание.

# **Сети типа мост (bridge)**

По умолчанию для контейнеров используется bridge. При первом запуске контейнера Docker создает дефолтную bridge-сеть с одноименным названием. Эту сеть можно увидеть в общем списке по команде `docker network ls`:
![](images/Pasted%20image%2020231031212404.png)
Чтобы проинспектировать ее свойства, запустим команду `docker network inspect bridge`:
![](images/Pasted%20image%2020231031212412.png)
Вы также можете создать свои собственные bridge-сети при помощи команды `docker network create`, указав опцию `--driver bridge`.

Например, команда `docker network create --driver bridge --subnet` [192.168.100.0/24](http://192.168.100.0/24) `--ip-range` [192.168.100.0/24](http://192.168.100.0/24) `my-bridge-network` создает еще одну bridge-сеть с именем “my-bridge-network” и подсетью [192.168.100.0/24](http://192.168.100.0/24).

# **Bridge-интерфейсы в Linux**

Каждая bridge-сеть имеет свое представление в виде интерфейса на хосте. С сетью “bridge”, которая стоит по умолчанию, обычно ассоциируется интерфейс docker0, и с каждой новой сетью, которая создается при помощи команды `docker network create`, будет ассоциироваться свой собственный новый интерфейс.
![](images/Pasted%20image%2020231031212422.png)
Чтобы найти интерфейс, который ассоциируется с сетью, которую вы создали, введите команду `ifconfig`, чтобы вывести все интерфейсы, а затем найти тот интерфейс, который относится к созданной вами подсети. Например, если нам надо найти интерфейс для сети my-bridge-network, которую мы только что создали, то можно запустить такую команду:
![](images/Pasted%20image%2020231031212433.png)
Bridge-интерфейсы Linux похожи на свичи тем, что они присоединяют несколько интерфесов к одной подсети и перенаправляют трафик на основе MAC-адресов. Как будет видно ниже, у каждого контейнера, привязанного к bridge-сети, будет свой собственный виртуальный интерфейс на хосте, и все контейнеры в одной сети будут привязаны к одному интерфейсу, что позволит им передавать друг другу данные. Можно получить больше данных о статусе моста при помощи утилиты `brctl`:
![](images/Pasted%20image%2020231031212441.png)
Как только мы запустим контейнеры и привяжем их к этой сети, интерфейс каждого из этих контейнеров будет выведен в списке в отдельной колонке. А если включить захват трафика в bridge-интерфейсе, то можно увидеть, как передаются данные между контейнерами в одной подсети.

# **iptables**

Docker использует linux iptables, чтобы контролировать коммуникации между интерфейсами и сетями, которые он создает. Linux iptables состоят из разных таблиц, но нам в первую очередь интересны только две из них: filter и nat. Таблица filter содержит правила безопасности, которые решают, допускать ли трафик к IP-адресам или портам. С помощью таблицы nat Docker дает контейнерам в bridge-сетях связываться с адресатами, которые находятся снаружи хоста (иначе пришлось бы добавлять маршруты к контейнерным сетям в сети хоста).

# **Взаимодействие контейнеров**

Запуск нескольких докер-контейнеров осуществляется обычно с целью взаимодействия этих контейнеров.

За пример возьмём обычное web-приложение.

В первом контейнере располагается статичный контент и веб-сервер, а во втором restfull-сервис и данные.
![](images/Pasted%20image%2020231031212449.png)
# Сеть в docker

Docker умееть в сети, по умолчанию есть следующие:
- bridge
- host
- none
Контейнеры подключаются к bridge по-умолчанию, а тот уже раздаёт IP адреса из своего диапазона, и через сетевые мосты перенаправляет траффик в большой интернет. Самое приятное: если пытливый программистский разум не вмешивался в настройки Докера, то все контейнеры внутри своей сети могут свободно видеть друг друга и общаться между собой, а снаружи к ним можно достучаться только привязав контейнерные порты к  портам хоста (например, -p 80:80 ).
```
docker run -d nginx
#6e47c39f797a71429971e5c2df59305dd5bd2e47bd901e2f404de18a53aefa53
docker inspect --format '{{ .NetworkSettings.IPAddress }}' 6e4
#172.17.0.2
docker run -ti busybox
#/ # 
wget -qO- 172.17.0.2
#<!DOCTYPE html>
#<html>
#<head>
#<title>Welcome to nginx!</title>
#<style>
#...
```
То есть, зная IP адрес контейнера, общаться с ним — не проблема. А вот знать адрес контейнера — проблема. То, что сегодня nginx висит на 172.17.0.2 совсем не значит, что здесь же он будет и завтра. Поменялся порядок запуска контейнера, перенесли его в другую сеть, поменяли настройки Docker-сервера — и айпишка поменялась. Нужно что-то более постоянное.


Давайте посмотрим, как происходит общение контейнеров по сети.

Для этого стоит

- создать 2 контейнера (один из них — допустим, container1 — нужно запустить в интерактивном режиме);
- узнать при помощи команды docker inspect IP-адрес контейнера, запущенного не в интерактивном режиме (container2);
- проверить доступность container2 из оболочки container1 при помощи ping;
- вы увидите, что между контейнерами происходит общение по IP-адресу.

Чтобы общение происходило через DNS, вам нужно создать новую сеть, имя которой будет отличаться от bridge, так как у сети по умолчанию bridge такой возможности не предусмотрено.

Чтобы обратиться к хосту из bridge, вам понадобится default gateway — его вы можете найти в inspect — это адрес, по которому происходит обращение к хосту.

Для обратного обращения — от хоста к контейнеру — можно пробросить порты, а можно воспользоваться тем же адресом, о котором мы говорили выше. Он доступен с хоста.



Docker-compose концепция оркестратора

Docker контейнерами можно управлять вручную, что для некоторых эпизодических тестов является весьма действительным и функциональным. Но когда количество контейнеров становится немного больше ими становится упарвляться на порядок сложнее и такой подход уже  не стоит использовать. Именно здесь в игру вступает оркестровка контейенеров для эффективного управления несколькими контейнерами.
Оркестровка контейнеров — это централизованное и эффективное управление и мониторинг контейнеров. Не только самих контейнеров, но и их окружения, включая их отношения и связи друг с другом.
Инструмент оркестровки должен иметь как минимум 4 ключевых элемента:
- Развертывание
- Масштабирование
- Web
- Надежность
Развертывание, как следует из названия, — это возможность эффективного развертывания наших контейнеров. Такое развертывание обычно осуществляется с помощью манифестов. (мы рассмотрим эти манифесты позже).

Под масштабированием понимается возможность увеличения количества запущенных контейнеров простым способом. Если, например, у нас есть контейнер, в котором работает веб-сервер, и трафик растет, мы можем масштабировать его и дублировать один и тот же контейнер столько раз, сколько необходимо для удовлетворения спроса. Масштабирование работает не только в смысле роста, количество реплик контейнера также может быть уменьшено, если, например, уменьшится трафик.

Хороший оркестровщик должен уметь управлять внутренней сетью, объединяющей контейнеры. Как мы узнали, контейнеры обычно одноразовые, мы можем поднимать или останавливать эти контейнеры в соответствии с конкретными потребностями нашего приложения, поэтому очень сложно управлять ips-адресами каждого контейнера. Для этого инструменты оркестровки способны генерировать внутренние сегменты сети для наших приложений, в дополнение к наличию сетевых балансировщиков и службы DNS, которая позволит нам обращаться к различным элементам нашего приложения по имени, без необходимости управлять ip-адресами.

Надежность:оркестратор должен быть способен поддерживать работоспособность нашего приложения; как только мы объявим контейнеры, которые должны быть развернуты для нашего приложения, оркестратор позаботится о том, чтобы они всегда были доступны. Мы знаем, что контейнеры одноразовые, они останавливаются и умирают; в таких случаях их приходится запускать снова или даже возводить совершенно новый, чтобы заменить умерший контейнер. Оркестратор способен выполнять эти задачи автоматически, поднимая умирающие контейнеры на основе того, что мы ему объявляем.
Это может показаться немного сложным, но не волнуйтесь, как только мы перейдем к делу, вы увидите, что это простые для понимания концепции, и что на самом деле именно оркестратор берет на себя решение сложных задач; нам нужно только побеспокоиться о правильном объявлении того, что мы хотим, чтобы делал оркестратор.

В нашем случае для начала нашего путешествия с оркестраторами мы будем использовать один из самых простых, Docker Compose, который содержит все описанные выше элементы и очень прост в использовании.


Что такое Docker Compose?

Это инструмент, который позволяет нам запускать несколько взаимодействующих контейнеров простым способом, используя манифесты, в данном случае в формате YAML. В этом манифесте мы определяем желаемое состояние. Docker Compose позаботится обо всех действиях, необходимых для поддержания этого состояния, и, что самое приятное, это можно сделать с помощью одной команды.

В общем, для использования любого оркестратора желаемое состояние обычно объявляется в одном или нескольких манифестах; это, по сути, принцип Infrastructure as Code (IaC).
Манифесты в Docker Compose записываются в формате YAML, который является очень распространенным форматом в других типах оркестраторов, также очень распространенных, таких как Kubernetes или Docker Swarn, поэтому то, что мы узнаем здесь, будет полезно, когда мы перейдем к этим более мощным и сложным инструментам.

Примером простого yaml манифеста Docker Compose для базы данных Mysql может быть:
```

version: '3.1'
services:
db:
image: rameijeiras/pandorafms-percona-base
environment:
MYSQL_ROOT_PASSWORD: pandora
MYSQL_DATABASE: pandora
MYSQL_USER: pandora
MYSQL_PASSWORD: pandora
ports:
- "3306:3306"
```

Как вы видите, это похоже на то, что мы делаем в команде Docker run, но в формате YAML.

Этот манифест гомологичен ручному выполнению команды:

```
docker run --name db \
-p 3306:3306 \
-e MYSQL_ROOT_PASSWORD=pandora \
-e MYSQL_DATABASE=pandora \
-e MYSQL_USER=pandora \
-e MYSQL_PASSWORD=pandora \
-d rameijeiras/pandorafms-percona-base
```


После сохранения манифеста, обычно в файле docker-compose.yml, мы просто переходим в директорию этого файла и выполняем команду docker-compose up. Автоматически Docker Compose выполнит необходимые задачи для создания контейнера: загрузит образ, если у нас нет его локально, установит объявленные переменные окружения и выставит порт 3306 контейнера на порт 3306 хоста, как мы объявили.

Для этого контейнера преимущества compose перед выполнением команды Docker run не очень заметны. В данном случае это отсутствие необходимости запускать длинную команду и возможность сделать это более простой командой, но когда нам нужно управлять более чем одним контейнером и объединять их, именно тогда полезность такого оркестратора, как Docker Compose, становится очевидной.



