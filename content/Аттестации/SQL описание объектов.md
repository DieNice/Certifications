---
tags:
  - Аттестация
date: 2024-07-11
author: Проскурин Д.А
---
# Общие принципы

При формировании названий объектов базы данных необходимо придерживаться следующих общих рекомендаций:

-   названия объектов должны быть ограничены 30 символами;
-   при именовании объектов (название БД, таблицы, поля, представления) необходимо использовать snake_case;
-   названия объектов не должны содержать пробелов;
-   желательно чтобы названия объектов не содержали более 3-4 слов;
-   рекомендуется использовать общепринятые сокращения и аббревиатуры в случае, если приведённые выше рекомендации соблюсти не удастся;
-   названия объектов должны содержать только латинские символы;
-   описание объектов должно быть интуитивно понятно пользователю;
-   описание свойств объектов в snake_case;
-   необходимо стараться давать максимально короткие имена с целью обеспечения хорошей управляемости.

Приведённые выше общие рекомендации могут быть уточнены в соответствующих разделах текущего документа.  
Названия объектов должны быть согласованы с ответственным хранилища данных.

# Схемы данных

Помимо общих ограничений на название схемы накладываются следующие:
-   название должно состоять из 1 слова в нижнем регистре;
-   длина слова не должна превышать 10 символов.

# Таблицы
Таблицы необходимо именовать во множественном числе латиницей.
Пример: registries, transactions

Нижеизложенные рекомендации справедливы для архитектуры хранилища данных.
Таблицы делятся на 3 типа:
-   Измерения (Измерения — это категориальные атрибуты, наименования и свойства объектов, участвующих в некотором бизнес-процессе) - префикс `dim_`. Основные признаки измерения: явно выделен первичный ключ (по одному столбцу) + на эту таблицу будут ссылаться другие таблицы.
-   Факты (Факты — это данные, количественно описывающие бизнес-процесс, непрерывные по своему характеру, то есть они могут принимать бесконечное множество значений) - префикс `fact_`. Основные признаки факта: множество записей в таблице, первичный ключ основан на нескольких столбцах, на эту таблицу не ссылаются другие, имеются числовые столбцы, к которым "хочется применить агрегатные функции".
-   Метаданные (Метаданные - это категориальные атрибуты, наименования и свойства объектов, участвующих в бизнес-процессе работы хранилища данных) - префикс `md_`. Основные признаки метаданных: таблица не попадает, либо попадает, но с большой натяжкой, под первые 2 пункта.

# Столбцы
Столбцы делятся на 4 типы:
* Первичные ключи - id (uuid). Желательно использование uuid;
* Идентификаторы (измерений). Желательно uuid;
* Числовая информация, поддающаяся агрегации;
* Дополнительная текстовая информация;

**Первичные ключи (id) присутствуют у всех измерений**. Это числовые типы данных: TINYINT, SMALLINT, INT. 
* TINYINT (ограничение в 128 значений) используется когда в измерении ожидается не более 50 элементов. 
* SMALLINT (ограничение около 32 000 положительных значений) используется, когда в измерении ожидается не более 10 000 элементов. В остальных случаях используется INT.  
Если в источнике первичный ключ INT, то в хранилище он также становится первичным ключом, даже если физически в нем значений меньше. 
uuid — стандарт идентификации, используемый в создании программного обеспечения, стандартизированный Open Software Foundation как часть DCE — среды распределённых вычислений. Основное назначение uuid — это позволить распределённым системам уникально идентифицировать информацию без центра координации.

Имя первичного ключа по одному столбцу – id (uuid).

**Идентификаторы измерений** (ссылки на измерения) именуются как "имя_таблицы_измерения" + id(uuid), например: branch_uuid (ссылка на dim_branch). Если в таблице присутствует несколько ссылок на измерения, то они именуются следующим образом: "имя_таблицы_измерения" + "имя_для_отличия" + uuid, например: staff_first_uuid и staff_last_uuid (ссылка на dim_staff) - первый и последний сотрудник (имеется ввиду автор документа и последний его редактор). Количество слов в названии столбца идентификатора измерения может быть больше 3, но не должно превышать 6.  

**Числовой столбец** именуется как "описание принадлежности" + "название", где "описание принадлежности" - характеристика какого объекта описывается в этом поле (например, product); "название" - значение характеристики (sum, count, price). Пример: product_price - цена товара, product_count - количество товаров.  

**Дополнительная информация** не связана ни с измерениями, ни с агрегацией. Ею может быть: номер документа (number_document), тип документа (document_type).  
Столбцы, которые служат в источнике идентификатором называем source_id, если идентификатор бинарные данные или uuid (guid), если идентификатор цифровой или символьный, то применяем название поля code.  

**Комментарии к документам** желательно выносить в отдельную таблицу, особенно если строки с документом в таблице дублируются (из-за соединения с табличной частью документа, например, продажи + состав товаров в продаже).  
В описании столбца должен быть комментарий, однозначно и понятно описывающий значение поля, если это требуется.

# Внешние ключи
Название внешнего ключа состоит из:
Полное название таблицы внешнего ключа (куда ссылается) в единственном числе + поле таблицы куда ссылается.
Все части названия отделены между собой нижним подчерком.  
**Примеры:**
Таблица 1:
credit_organizations_registry_configs [id, mail, letter_subject, ...]
regestries [id, file_name, date_download,...]
Внешний ключ в таком случае: credit_organization_registry_config_id

# Индексы

Основные используемые индексы подразделяются на кластеризованые и некластеризованные.
Индексы могут иметь как один ключ, так и быть составными. К названиям индексов применяются общие правила именования. Названия первичных ключей генерируются автоматически и не изменяются. В остальных случаях именование происходит по имени ключа. Если индекс составной, то называть индекс следует по первому ключу индекса.

Некластеризованные индексы при первичном создании таблицы необязательны и их можно создать уже впоследствии при необходимости. К ним применяются Такие же правила именования, как и к кластеризованным.

Создавать индексы можно как скриптом, так и используя функционал интерфейса Dbeaver.

# Представления

К названиям представлений применяются те же правила, что и к названиям таблиц.

# Функции и процедуры

В скрипте создания функции или процедуры необходимо заполнять "шапку" комментария:

```
-- =============================================
-- author: Имя Фамилия
-- create_date: Текущая дата
-- description: Краткое описание объекта
-- =============================================
```

К названиям применяются те же правила, что и к названиям таблиц, за исключением того что вместо префиксов `dim_`, `fact_` и др. могут использоваться префиксы "get_" (для полечения данных) и "set_" (для записи данных).

# Описание моделей ORM

* Именование класса CamelCase.
* Doc-string с описанием модели/таблицы.
* `__tablename__`  - название таблицы в БД во множественном числе;
* id/uuid - обязательное поле, первичных ключ;
* внешние ключи - внешняя таблицы в единственном числе  + id (uuid);
* обратная ссылка на связанную таблицу (secondary) - название внешней таблицы во множественном числе + название таблицы (можно сокращенное);
* обязательно функция repr, выводящая краткое описание объекта модели. 

```python
class CreditOrganizationStatement(db.Model):
    """Модель банковской выписки
    """
    __tablename__ = "credit_organization_statements"
    id = db.Column(UUIDType(binary=False), primary_key=True,
                   default=uuid.uuid1)
    credit_organization_id = db.Column(UUIDType(
        binary=False), db.ForeignKey("credit_organizations.id"), nullable=False)
    document = db.Column(db.String(30), nullable=False,
                         default="Description Statement")
    document_link = db.Column(UUIDType(binary=False), nullable=False)
    date_time_doc = db.Column(
        db.DateTime, nullable=False, default=datetime.now())
    row_number = db.Column(db.SmallInteger, nullable=False)
    payment_order = db.Column(db.String(200))
    sum_received = db.Column(db.Float, nullable=False)
    operation_uuid = db.Column(UUIDType(binary=False), nullable=False)
    transactions = db.relationship(
        Transaction, secondary="statements_revises", backref=db.backref("transactions_statements"), cascade="all,delete")

    def __repr__(self) -> str:
        return f"CreditOrganizationStatement {self.document},{self.sum_received}"
```

[[../Postgres/PostgreSQL Найти и уничтожить зависшие запросы  by Alexey Lukyanov  Medium]]
[[../Postgres/Хранимые процедуры на Python в PostgreSQL]]
[[../Postgres/pl_pgsql/Серверное программирование на PL pgSQL]]
[[../Postgres/Триггерные процедуры (функции)]]