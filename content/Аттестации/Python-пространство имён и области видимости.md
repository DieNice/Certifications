 # Виды областей видимости


>[!question] Типы области видимости
>* локальная
>* Нелокальная
>* Глобальная

>[!question] Примеры области видимости. Код.


>[!question] Для чего используется оператор nonlocal?
> nonlocal позволяет хранить в памяти множество копий изменяемого состояния

![](../../images/Pasted%20image%2020231114100328.png)


 # Пространство имён
 
>[!question] Для чего нужны области видимости?
>Подобно файлам модулей области видимости помогают предотвратить конфликты имен в коде программы: имена, определяемые в одной программной единице, не пересекаются с именами в другой.

>[!question] Как присвоить имя, которое существует на верхнем уровне модуля внутри функции?
>global

>[!question] Как присвоить имя в нелокальной области видимости из локальной?
>nonlocal

>[!question] Что происходит с областью видимости при каждом вызове функции?
> Каждый вызов функции создает новую локальную область видимости. Всякий раз, когда вы вызываете функцию, создается новая локальная область видимости, т.е. пространство имен, в котором обычно будут существовать имена, созданные внутри функции. Вы можете думать о каждом операторе def (и выражении lambda) как об определении новой локальной области видимости, но локальная область видимости в действительности соответствует вызову функции.

>[!question] Что происходит с областью видимости в рекурсии?
> каждый активный вызов получает собственную копию локальных переменных функции

>[!question] Принцип работы присваивания и изменения объектов относительно локальной и глобальной области видимости
>   Также обратите внимание, что присваивание любого вида внутри функции классифицирует имя как локальное, включая операторы =, имена модулей в операторе import, имена функций в операторе def, имена аргументов функций и т.д. Присваивание имени любым способом внутри def по умолчанию делает его локальным в данной функции.
>   Наоборот, изменения на месте объектов не классифицируют имена как локальные;
>   так поступают только присваивания действительных имен. Скажем, если имени L присваивается список на верхнем уровне модуля, то оператор L = X внутри функции будет классифицировать L как локальное имя, но L. append (X) — нет. В последнем случае мы изменяем списковый объект, на который ссылается L, а не само имя L — переменная L находится в глобальной области видимости, как обычно, и Python успешно модифицирует ее, не требуя объявления global (или nonlocal). Как всегда, это помогает сохранять четкое различие между именами и объектами: изменение объекта не является присваиванием имени.

# Правило LEGB
![](../../images/Pasted%20image%2020231114094444.png)

Ниже описана схема распознавания имен Python, которая иногда называется правилом, LEGB согласно названиям областей видимости.
- Когда внутри функции указывается неуточненное имя, Python ищет его максимум в четырех местах — в локальной (L (local)) области видимости, затем в локальных областях видимости любых объемлющих (Е (enclosing)) операторов def и lambda, далее в глобальной (G (global)) области видимости и, наконец, во встроенной (В (built-in)) области видимости — и останавливает поиск на первом же месте, где обнаруживается имя. Если в результате такого поиска имя найти не удалось, тогда Python сообщит об ошибке
- Когда внутри функции выполняется присваивание имени (вместо просто ссылки на него в выражении), Python всегда создает либо изменяет имя в локальной области видимости, если только оно не было объявлено в этой функции как глобальное или нелокальное.
- Когда производится присваивание имени за пределами всех функций (т.е. на верхнем уровне файла модуля или в интерактивной подсказке), локальная область видимости совпадает с глобальной — пространством имен модуля.

# Другие области видимости Python

> [!question] Область видимости list comprehesion
> Переменные включений — переменная X, применяемая для ссылки на элемент  текущей итерации в выражении включения вроде [X for X in I]. Поскольку  они могут конфликтовать с другими именами и отражать внутреннее состояние  в генераторах, в Python З.Х такие переменные являются локальными для самого  выражения во всех формах включений: генератора, списка, множества и словаря. В Python 2.Х они локальны в генераторных выражениях, а также во включениях множеств и словарей, но не в списковых включениях, которые отображают свои имена на область видимости за пределами выражения. Напротив,  операторы цикла for никогда не локализуют свои переменные внутри блока  операторов в любой версии Python. За дополнительными деталями и примерами обращайтесь в главу 20.

>[!question] Область видимости исключений
>Переменные исключений — переменная X, используемая для ссылки на сгенерированное исключение в конструкции обработчика оператора try наподобие except Е as X. Из-за того, что они могут задерживать освобождение памяти при сборке мусора, в Python З.Х такие переменные являются локальными в этом блоке except и на самом деле уничтожаются при выходе из блока (даже если они применялись ранее в коде!)


# Задачки

![](../../images/Pasted%20image%2020231114100523.png)

# Дополнительные вопросы

>[!question] Можно ли изменять область видимости во время выполнения программы?  
Область видимости класса в Python не может быть изменена во время выполнения программы. Однако, внутри функции можно создавать классы, которые будут доступны только внутри этой функции, и не будут доступны глобально.  
  
>[!question] Как будет происходить поиск метода или атрибута внутри класса?  
  Интерпритатор сначала проверяет экземпляр класса(объект) -> проверяется класс -> проверяются все классы по порядку наследования -> класс object -> ошибка AttributeError  
  
>[!question] Как области видимости классов влияют на порядок разрешения имен в множественном наследовании? Что будет, если мы захотим вызвать метод, который определен в нескольких родительских классах?  
  Области видимости классов влияют на порядок разрешения имен в множественном наследовании. Если класс наследуется от нескольких родительских классов, порядок разрешения имен определяется порядком наследования классов. Если у родительских классов есть атрибуты или методы с одинаковыми именами, будет использоваться атрибут или метод, определенный в первом родительском классе, который указан в порядке наследования.  
  
>[!question] Как области видимости классов влияют на порядок разрешения имен в случае иерархического множественного наследования?  
Области видимости классов влияют на порядок разрешения имен в случае иерархического множественного наследования. Если класс наследуется от нескольких родительских классов, которые сами наследуются от других классов, порядок разрешения имен определяется порядком наследования классов и их родителей. Если у родительских классов есть атрибуты или методы с одинаковыми именами, будет использоваться атрибут или метод, определенный в первом родительском классе, который указан в порядке наследования.  
  
>[!question] Как области видимости классов влияют на доступность атрибутов и методов в множественном наследовании?  
Области видимости классов влияют на доступность атрибутов и методов в множественном наследовании. Если атрибут или метод определен как публичный (public), он будет доступен везде. Если атрибут или метод определен как защищенный (protected), он будет доступен внутри класса и в его подклассах. Если атрибут или метод определен как приватный (private), он будет доступен только внутри класса.  
  
>[!question] Знаешь ли ты, что у всех классов есть метод mro()? Для чего он нужен?  
Да, все классы в Python имеют метод mro() (Method Resolution Order), который возвращает список классов, которые будут использоваться для разрешения методов и атрибутов при множественном наследовании. Этот метод полезен для понимания порядка, в котором Python будет искать методы и атрибуты в классах при множественном наследовании.  
Он может быть использован для отладки и понимания поведения классов, а также для предотвращения конфликтов имен и неоднозначности при использовании множественного наследования. ( Метод mro() позволяет понять порядок, в котором будут разрешаться методы и атрибуты в классах при множественном наследовании.)

# Ссылки
1. Лутц М. - Изучаем Python, том 1, 5-е издание - 2019.pdf
