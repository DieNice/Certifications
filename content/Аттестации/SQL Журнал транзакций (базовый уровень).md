---
date: 2024-03-10
tags:
  - Usefull
  - Аттестация
  - Postgres
---
# Надежность

Надежность одной из важнейших свойств современной СУБД, В Postgres данные записываются при помощи **подтвержденных транзакций**, которые сохраняются в энергонезависимой области. В случае выхода из троя сервера и при условии, что диски живы все подтвержденные транзакции останутся неповреждёнными [^1].
Внешние диски Значительнее медленнее чем процессор или оперативная память. Между ОП и диском есть специализированные **механизмы кеширования**.

## Буферный кеш
![](../../images/Pasted%20image%2020240312223801.png)

## Вытеснение
![](../../images/Pasted%20image%2020240312223831.png)



>[!note] Существует принудительный способ записи из "буферного кеша ОС" на диск.

## Режимы работы с кешем
Некоторые диски имеют специализированный контроллер, который умеет управлять кешированием. Работа с кешем может осуществляться в режиме "сквозной" и "отложенной" записи.

>[!tip] Сквозная запись
>Сквозная записи подразумевает, что как только запись попадает в кеш она сразу записывается на диск.

>[!tip] Отложенная запись
> Отложенная запись подразумевает , что запись происходит некоторое время спустя. В таком случае возможны потери в случае отключения электропитания. У некоторых дисков на такой случай есть батарея резервного питания.

У многих дисков есть внутренний кеш. Такие диски также могут работать в сквозном и отложенном режиме.

>[!advice] Кеш отложенной записи может быть отключен

При запросе на запись к аппаратному обеспечению для хранения данных , ОС может мало что сделать, чтобы убедиться что данные действительно сохранены. **ЭТО ОТВЕТСТВЕННОСТЬ** администратора (установка диска с контроллерами, которые имеют резервное питания, запрет отложенной записи и т.д.).

>[!danger] Во время записи на диск может возникнуть ситуация при которой некоторые сектора не запишутся до конца. Чтобы защититься от сбоев в Postgres перед изменением физической страницы на диске переодичски записываются полные образы страниц на постоянное устройство хранения WAL. При помощи этого Postgres может восстановить страницы записанные частично.

## Механизмы защиты данных в Postgres
**Некоторые механизмы защиты данных в Postgres:
- Каждая запись WAL защищена при помощи контрольной суммы;
- Страницы данных НЕ защищаются контрольными суммами по умолчанию;
- Временные файлы данных , используемые во время выполнения больших SQL-запросов (сортировка, материализация и промежуточные результаты) не защищаются контрольными суммами и не записываются в WAL.
- Больше смотри [^1] стр. 834.

# Контрольные суммы данных
По умолчанию страницы данных не защищены контрольными суммами. Данную функциональность можно включить при инициализации кластера или когда он остановлен. Стоит отметить, что данную функцию нельзя включить отдельно для базы данных или таблицы.
>[!tip] Контрольная сумма рассчитывается при записи и проверяется при каждом чтении страницы.

# Журнал предзаписи WAL
**WAL (Write Ahead Logging)**
![](../../images/Pasted%20image%2020240312224427.png)

Журнал предзаписи WAL - это стандартный метод обеспечения целостности базы данных. Основная суть заключается в том что перед каждым фактическим изменением файлов с данными должна произойти успешная запись изменений в WAL. В WAL описываются изменения и только после этого эти изменения применяются в файлу с данными (таблицы и индексы). 
>[!info] WAL особенности 
> Если следовать этой процедуре, то записывать страницы на диск после каждой успешной записи в WAL нет необходимости. Т.к. в случае сбоя мы можем полностью восстановить базу из WAL.
> Файл WAL записывается последовательно, таким образом затраты на запись WAL значительно меньше чем затраты на запись страниц с данными.
> Результатом использования WAL является значительное уменьшение количества запросов записи на диск.
> С помощью архивирования данных WAL поддерживается возврат к любому моменту времени, который доступен в данных WAL (устанавливаем предыдущую физическую копию базы данных и воспроизводим WAL до нужного момента времени. WAL также может исправить все внутренние несоответствия)

>[!danger] Файлы журнала располагаются в каталоге PGDATA/pg_wal.

## Что не попадает в журнал

>[!danger] В журнал не попадают данные о временных таблицах (такие таблицы доступны только создавшему их пользователю и только на время сеанса или транзакции) и о нежурналируемых таблицах (такие таблицы ничем не отличаются от обычных, кроме того, что не защищены журналом). В случае сбоя нежурналируемые таблицы просто очищаются, зато работа с ними происходит быстрее.

![](../../images/Pasted%20image%2020240312231357.png)

# Асинхронное подтверждение транзакций

Скорость выполнения транзакций можно увеличить использовав асинхронный метод подтверждения транзакций. Это означает что ответ об успешном **логическом** завершении транзакции приходит клиенту практически сразу, а фактическая запись в WAL происходит позже. В данном подходе есть риск краха сервера в небольшом окне между подтверждением логического завершения транзакции и записи в WAL, в таком случае восстановить последние транзакции не получится, т.к. они не зафиксированы.
![](../../images/Pasted%20image%2020240312225307.png)

![](../../images/Pasted%20image%2020240312225720.png)

>[!advice] Пользователь может выбрать режим подтверждения для каждой транзакции, так что возможен конкурентный запуск транзакций в синхронном и асинхронном режиме. Для управления  режимом подтверждения транзакций существует параметр synchronous_commit. [^8]

По умолчанию PostgreSQL обеспечивает согласованность. Это контролируется параметром сервера `synchronous_commit`. По умолчанию он в положении `on`, но у него есть три других варианта: `local`, `remote_write` или `off`.
При установке параметра в `off` останавливаются все синхронные коммиты, даже в локальной системе.
**Параметр в local** определяет синхронный режим для локальной системы, но записи в реплики производятся асинхронно.
`Remote_write` заходит еще дальше: записи в реплики производятся асинхронно, но возвращаются, когда реплика приняла запись, но не записала ее на диск.
Рассматривая имеющийся диапазон опций, мы выбираем поведение и, помня о том, что `on` – это синхронные записи, мы выберем `local` для асинхронных коммитов по сети, при этом оставив локальные коммиты синхронными.
Теперь, мы расскажем вам, как настроить это в одно мгновенье, но представьте, что мы установили `synchronous_commit` в `local` для сервера. Мы задались вопросом, можно ли изменять параметр `synchronous_commit` на лету, и оказалось, что не просто можно, для этого даже есть целых два способа. Первый – это задать сессию вашего соединения следующим образом:
  
```postgresql
SET SESSION synchronous_commit TO ON;  
// Your writes go here
```

Все последующие записи в сессии будут подтверждать операции записи для реплик, прежде чем возвращать положительный результат подключенному клиенту. Если, конечно, вы не измените настройку `synchronous_commit` снова. Можно опустить часть `SESSION` в команде, поскольку она будет в значении по умолчанию.
Второй способ хорош, когда вы просто хотите убедиться, что получаете синхронную репликацию для одной транзакции. Во многих базах данных поколения "NoSQL" понятия транзакций не существует, но оно существует в PostgreSQL. В этом случае вы запускаете транзакцию, а затем устанавливаете `synchronous_commit` в `on` перед выполнением записи для транзакции. `COMMIT` зафиксирует транзакцию, используя любое значение параметра `synchronous_commit`, которое было установлено в тот момент, хотя лучше всего задавать переменную заранее, чтобы убедиться, что другие разработчики понимают, что записи не являются асинхронными.
```postgresql
BEGIN;  
SET LOCAL synchronous_commit TO ON;  
// Your writes go here
COMMIT;  
```

Все коммиты транзакций теперь будут подтверждаться, как записанные в реплики еще до того, как база данных вернет положительный ответ подключенному клиенту.

## Настройка PostgreSQL

До этого мы представляли себе систему PostgreSQL с `synchronous_commit`, установленным в `local`. Чтобы это было реально на стороне сервера, вам нужно будет установить два параметра конфигурации сервера. Еще один параметр `synchronous_standby_names` будет вступать в свои права, когда `synchronous_commit` будет в `on`. Он определяет какие реплики имеют право на синхронные коммиты, и мы установим его в `*`, что будет означать задействование всех реплик.
```postgresql
synchronous_commit = local  
synchronous_standby_names='*'
```
Установив параметр `synchronous_commit` в значение `local`, мы создаем систему, в которой локальные диски остаются синхронными, но коммиты сетевых реплик по умолчанию являются асинхронными. Если, конечно, мы не решим сделать эти коммиты синхронными, как показано выше.

| значение  <br>synchronous_commit | гарантирован  <br>ная локальная  <br>фиксация | гарантирован  <br>ная фиксация  <br>на ведомом  <br>после сбоя PG | гарантирован  <br>ная фиксация  <br>на ведомом  <br>после сбоя ОС | согласован  <br>ность запро  <br>сов на ведо  <br>мом |
| -------------------------------- | --------------------------------------------- | ----------------------------------------------------------------- | ----------------------------------------------------------------- | ----------------------------------------------------- |
| remote_apply                     | •                                             | •                                                                 | •                                                                 | •                                                     |
| on                               | •                                             | •                                                                 | •                                                                 |                                                       |
| remote_write                     | •                                             | •                                                                 |                                                                   |                                                       |
| local                            | •                                             |                                                                   |                                                                   |                                                       |
| off                              |                                               |                                                                   |                                                                   |                                                       |

# Настройка WAL

Существует несколько параметров относящиеся к WAL, которые влияют на производительность СУБД.

## Контрольная точка 
![](../../images/Pasted%20image%2020240312224910.png)


**Контрольные точки** - это точки в последовательности транзакций, в которых гарантируется что все файлы с данными и индексами были обновлены всей информацией записанной перед контрольной точкой. Во время "checkpoint-а" все данные сбрасываются из памяти на жесткий диск (все "грязные" страницы с данными в памяти сохраняются на диск).
В случае краха процедура восстановления ищет последнюю точку восстановления называемую REDO и и применяет изменения. Изменения всех файлов перед контрольной точкой уже находятся на диске, поэтому записи WAL перед контрольной точкой не востребованы и могут быть удалены или направлены на циклическую перезапись.
Сброс данных на диск в момент создания контрольной точки может создать значительную нагрузку на чтение/записи. Чтобы оптимизировать производительность, ввод/вывод "растягивают" от момента создания контрольной точки до момента создания следующей контрольной точки. Всё это выполняется с заданной частотой.

>[!warning] Отметим, что страницы не вытесняются из кеша, а только записываются

>[!tip] Также можно выполнить контрольную точку принудительно, воспользовавшись SQL-командой CHECKPOINT

Чем чаще интервал создания контрольный точек, тем быстрее можно восстановить БД после сбоя.
Контрольные точки дороги с точки зрения использования ресурсов (доп. трафик в WAL, ввод/вывод на диски)  , потому параметр частоты сбора нужно установить так, чтобы точки не выполнялись слишком часто.

Интересные параметры:
- checkpoint_completion_target;
- checkpoint_warning;
- checkpoint_timeout;
- max_wal_size;
- archive_timeout;
- wal_sync_method;

Также можно поиграться с параметрами, отвечающие за оптимальную работу с буферами Postgres и WAL (Документация к PostgreSQL 16.1  стр. 839).

# Внутреннее устройство WAL

WAL включается и настраивается автоматически.
Записи в WAL записываются по мере поступления. Позицию добавления в журнал определяет значение LSN (Log Sequence Number), смещение в байтах внутри WAL, которое монотонно увеличивается (для смещения есть свой тип pg_lsn). pg_lsn поддерживает операции сравнения и вычитания, так что можно определить объем данных WAL между двумя значениями (полезно для вычисления прогресса при репликации или восстановлении).
Файлы  WAL хранятся в виде набора файлов сегментов в каталоге **pg_wal**. Эти файлы имеют обычно размер в 16 Мбайт каждый.
Каждый файл сегмента разделяется на страницы по 8Кб.
После выполнения контрольной точки и сброса WAL позиция контрольной точки сохраняется в файл **pg_control**. При старте восстановления сервер читает pg_control и запись контрольной точки и выполняет операцию REDO.

На файлы можно взглянуть не только средствами файловой системы, но и с помощью функции:
```Postgresql
=> SELECT * FROM pg_ls_waldir() ORDER BY name LIMIT 10;
           name           |   size   |      modification      
--------------------------+----------+------------------------
 0000000100000002000000BC | 16777216 | 2024-02-06 11:09:42+03
 0000000100000002000000BD | 16777216 | 2024-02-06 10:27:56+03
 0000000100000002000000BE | 16777216 | 2024-02-06 10:27:36+03
 0000000100000002000000BF | 16777216 | 2024-02-06 10:28:16+03
 0000000100000002000000C0 | 16777216 | 2024-02-06 10:27:51+03
 0000000100000002000000C1 | 16777216 | 2024-02-06 10:27:36+03
 0000000100000002000000C2 | 16777216 | 2024-02-06 10:28:00+03
 0000000100000002000000C3 | 16777216 | 2024-02-06 10:27:40+03
 0000000100000002000000C4 | 16777216 | 2024-02-06 10:27:50+03
 0000000100000002000000C5 | 16777216 | 2024-02-06 10:28:05+03
(10 rows)
```


# Восстановление при помощи журнала WAL
Измененные табличные страницы находятся в буферном кеше, но еще не записаны на диск. При обычной остановке сервер выполняет контрольную точку, чтобы записать все грязные страницы на диск, но мы сымитируем сбой системы, послав сигнал процессу postmaster.

```Postgresql
student$ sudo head -n 1 /var/lib/postgresql/16/main/postmaster.pid

28448

student$ sudo kill -QUIT 28448

При старте произойдет восстановление согласованности данных с помощью журнала. Проверим:

student$ sudo pg_ctlcluster 16 main start

student$ psql arch_wal_overview

=> SELECT min(n), max(n) FROM t;

 min |  max   
-----+--------
   2 | 100001
(1 row)
```
Все изменения были восстановлены.
PostgreSQL автоматически удаляет журнальные файлы, не требующиеся для восстановления, после выполнения контрольной точки.

# Уровни журнала WAL
![](../../images/Pasted%20image%2020240312225833.png)

Как уже говорилось, причиной появления журнала является необходимость защищать информацию от сбоев из-за потери содержимого оперативной памяти.Однако журнал — механизм, который оказалось удобно применятьи для других целей, если добавить в него дополнительную информацию.
Объем данных, который попадает в журнал, регулируется параметром wal_level;
* На уровне minimal журнал обеспечивает только восстановление после сбо;
* На уровне replica в журнал добавляется информация, позволяющая использовать его для создания резервных копий (модуль «Резервное копирование») и репликации (модуль «Репликация»).При репликации журнальные записи передаются на другой сервери применяются там; таким образом создается и поддерживается точная копия (реплика) основного сервера;
* На уровне logical в журнал добавляется информация, позволяющая декодировать «физические» журнальные записи и сформироватьиз них «логические» записи о добавлении, изменении и удалении табличных строк. Это позволяет организовать логическую репликацию

# Выводы
- Буферный кеш существенно ускоряет работу, уменьшая число дисковых операций;
- Надежность обеспечивается журналированием;
- Размер журнала ограничен благодаря контрольным точкам;
- Журнал используется для: восстановления, резервном копировании , репликации; 

# Вопросы по материалу
1. Найти гайд как восстанавливать данные из журнала WAL;
2. Как выглядит внутри WAL;
   ![](../../images/Pasted%20image%2020240312231622.png)
# Дополнительно

## Truncate в WAL

Команда TRUNCATE быстро удаляет все строки из набора таблиц. Она действует так же, как безусловная команда DELETE для каждой таблицы, но гораздо быстрее, так как она фактически не  
сканирует таблицы.
Более того, она немедленно высвобождает дисковое пространство, так что выполнять операцию VACUUM после неё не требуется. Наиболее полезна она для больших таблиц.
TRUNCATE является надёжной транзакционной операцией в отношении данных в таблицах: опустошение будет безопасно отменено, если окружающая транзакция не будет зафиксирована.
Операция `TRUNCATE` может быть оптимизирована, используя нелогируемые таблицы (`unlogged tables`), которые не генерируют WAL и обновляются быстрее. Однако следует помнить, что данные в нелогируемых таблицах являются эфемерными и не сохраняются после сбоя системы.

При выполнении `TRUNCATE`, PostgreSQL записывает в журнал предзаписи (WAL) информацию о том, что таблица должна быть очищена. Это обеспечивает возможность восстановления данных в случае сбоя или необходимости восстановления данных до момента выполнения операции `TRUNCATE`.

В случае использования `TRUNCATE` в транзакции, операции вставки после `TRUNCATE` также не будут залогированы в WAL, если они выполняются в рамках той же транзакции. Это может быть полезно для уменьшения объема WAL, но важно учитывать, что в случае использования горячего резервного копирования (hot standby), данные все равно должны быть записаны в WAL для отправки на другой сервер.

Таким образом, при использовании `TRUNCATE` в PostgreSQL, важно учитывать, что операция будет залогирована в WAL, что обеспечивает возможность восстановления данных в случае сбоя. Однако, для оптимизации производительности и уменьшения объема WAL, можно рассмотреть использование нелогируемых таблиц или выполнение операций в рамках одной транзакции.
# Источники

[^1]: Документация к PostgreSQL 16.1 The PostgreSQL Global Development Group "Постгрес Профессиональный" (Глава 30 -> 30.3 Журнал предзаписи WAL).
[^2]: https://postgrespro.ru/education/courses/DEV1/).
[^3]: https://postgrespro.ru/education/courses/DEV2/).
[^4]: https://edu.postgrespro.ru/dev2/dev2_04_arch_wal.html
[^5]: https://edu.postgrespro.ru/dba2/dba2_09_wal_log.pdf
[^6]: https://edu.postgrespro.ru/16/dev1-16/dev1_04_arch_wal_overview.html
[^7]: https://edu.postgrespro.ru/dev2/dev2_13_ext_async.html
[^8]: https://habr.com/ru/companies/otus/articles/472364/
[^9]: Документация к PostgreSQL 16.1 The PostgreSQL Global Development Group "Постгрес Профессиональный" стр. 589 synchronous_commit.