![](images/Pasted%20image%2020231031214756.png)

# Конспект

Транзакции являются одним из фундаментальных концептов всех СУБД. Сущность транзакции состоит в связывании нескольких шагов в одну операцию по принципу все-или-ничего. Внутренние промежуточные состояния между шагами не видны для других конкурирующих транзакций и если во время выполнения транзакции случится ошибка, которая помешает транзакции завершится, то в базе данных никаких изменений сделано не будет.

Транзакции должны удовлетворять свойствам ACID

Атомарность. Транзакция либо выполняется полностью либо не выполняется вовсе.

Согласованность. При завершении транзакции не должны быть нарушены ограничения накладываемые на данные (например constraints в БД). Согласованность подразумевает, что система будет переведена из одного корректного состояния в другое корректное.

Изолированность. Параллельно выполняемые транзакции не должны влиять друг на друга, например менять данные которые использует другая транзакция. Результат выполнения параллельных транзакций должен быть таким, как если бы транзакции выполнялись последовательно.

Устойчивость. После фиксации изменения не должны быть утеряны.

Например, допустим, что есть база данных, которая содержит балансы для нескольких клиентов и общие депозитные балансы для филиалов. Предположим, что мы хотим внести поступление $100.00 от клиента Alice для клиента Bob. Простейшая команда, которая выполняет данную операцию может выглядеть так

```
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
UPDATE branches SET balance = balance - 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice');
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
UPDATE branches SET balance = balance + 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');

```
Делали этих команд сейчас не важны; важно что здесь мы имеем дело с несколькими отдельными обновлениями (операторы update), которые реализуют нужную нам операцию. Наши банковские работники захотят сделать так, чтобы все эти обновления происходили сразу или чтобы не происходило ни одно из них. Это обусловлено тем, что в результате какой-либо системной ошибки может получиться так, что Bob получит $100.00, которые не будут вычтены у Alice. Или может случиться так, что у Alice будет вычтена эта сумма, но Bob её не получит. Нам нужна гарантия, что если что-либо пойдет не так во время операций обновления, счетов, то никаких изменений фактически внесено не будет. Такую гарантию можно получить, если сгруппировать операторы update в транзакцию. Транзакция является атомарным действием с точки зрения других транзакций и либо она завершится полностью успешно, либо никакие действия, составляющие транзакцию выполнены не будет.

Мы также хотим гарантировать, что одна полностью завершившаяся и подтверждённая СУБД транзакция является действительно сохранённой и не может быть потеряна, даже если после её выполнения произойдет крах системы. Например, если мы сохраняем кэш перевода клиента Bob, мы не хотим, чтобы эти деньги клиента Bob потерялись в результате краха системы, который, например, может произойти как только Bob вышел за двери банка. Традиционные СУБД гарантируют что все обновления, осуществляемые в одной транзакции, протоколируются в надежное хранилище (т.е. на диск) перед тем как СУБД сообщит о завершении транзакции.

Другое важное свойство транзакционных СУБД состоит в строгой изоляции транзакций: когда несколько транзакций запускаются конкурентно, каждая из них не видит тех неполных изменений, которые производят другие транзакции. Например, если одна транзакция занята сложением всех балансов филиалов, она не должна учитывать как денег снятых со счета Alice так и денег пришедших на счет Bob. Таким образом транзакции должны выполнять принцип все-или-ничего не только в плане нерушимости тех изменений, которые они производят в базе данных, но и также в плане того, что они видят в момент работы. Обновления, которые вносит открытая транзакция являются невидимыми для других транзакций пока данная транзакция не завершиться, после чего все внесенные ей изменения станут видимыми.

В PostgreSQL транзакция - это список команд SQL, которые находятся внутри блока, начинающегося командой BEGIN и заканчивающегося командой COMMIT. Таким образом наша банковская транзакция будет выглядеть так

```
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
-- и т.д. ....
COMMIT;

```
Если во время выполнения транзакции мы решаем, что не хотим завершать её (например мы получили извещение о том, что счет Alice отрицательный), то мы вместо команды COMMIT выдаем команду ROLLBACK и все наши изменения от начала транзакции, будут отменены.

PostgreSQL фактически считает каждый оператор SQL запущенным в транзакции. Если вы не указываете команду BEGIN, то каждый отдельный оператор имеет неявную команду BEGIN перед оператором и (при успешной отработке оператора) команду COMMIT после оператора. Группа операторов заключаемая в блок между BEGIN и COMMIT иногда называется транзакционным блоком.

Note: Некоторые клиентские библиотеки выполняют команды BEGIN и COMMIT автоматически, так что вы можете без вопросов организовывать транзакционные блоки. Проверьте документацию по тому интерфейсу, который вы используете.

Возможно управлять операторами в транзакции и на более детализированном уровне с помощью "точек сохранения" (savepoints). Точки сохранения позволяют выборочно отбрасывать части транзакции, в то же время выполняя остаток транзакции. После того как вы зададите точку сохранения с помощью оператора SAVEPOINT, вы можете, если понадобится, откатить транзакцию до этой точки сохранения с помощью оператора ROLLBACK TO. Все изменения базы данных внутри транзакции между точкой сохранения и местом откуда вызван откат теряются, но изменения, которые были сделаны до точки сохранения остаются.

После отката к точке сохранения, она продолжает оставаться заданной и, таким образом, вы можете делать к ней откат несколько раз. И наоборот, если вы уверены, что вам не нужен снова откат к определённой точке сохранения, она может быть убрана, чтобы системе могла освободить некоторые ресурсы. Запомните, что откат к некоторой точке сохранения или её удаление, автоматически удаляет все точки сохранения, которые были заданы после неё.

Всё это происходит внутри транзакционного блока, так что ничего из этого не будет видно в других сессиях. Когда и если вы завершаете транзакционный блок, выполняемые действия становятся видимыми в других сессиях как единичная операция, в то время как действия по откату транзакции никогда не становятся видимыми для других сессий.

Возращаясь к базе данных банка, предположим, что мы списали $100 со счёта Alice и положили их на счёт Bob, только для того, чтобы потом обнаружить, что мы должны были положить их на счёт Wally. Мы могли бы сделать это, используя точки сохранения как здесь:

```
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
-- ой! ... забудем это и используем счёт Wally
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Wally';
COMMIT;

```
Этот пример, конечно, слишком прост, но он наглядно показывает возможность управления транзакционным блоком с помощью точек сохранения. Кроме того, оператор ROLLBACK TO является только способом перехвата управления для транзакционного блока, который был переключен системой в состояние отмены при возникновении какой-либо ошибки, вместо полного отката транзакции и начала её заново.


2. Блокировки таблиц

Блокировка (lock) в СУБД — отметка о захвате объекта транзакцией в ограниченный или исключительный доступ с целью предотвращения коллизий и поддержания целостности данных.

Понимание того как работают блокировки является ключом к написанию правильных запросов способных выполняться параллельно. Чтобы узнать как работают блокировки и увидеть, что происходит внутри базы данных, давайте рассмотрим наглядный пример.


Классификация блокировок

- По области действия блокировки классифицируются на строчные, гранулярные и предикатные.
- По строгости блокировки разделяются на совместные (англ. shared) и исключительные (эксклюзивные, англ. exclusive).
- По логике реализации блокировки делятся на оптимистические и пессимистические.
По области действия

Строчная блокировка — действуют только на одну строку таблицы базы данных, не ограничивая манипуляции над другими строками таблицы.

Гранулярная блокировка — действует на всю таблицу или всю страницу и все строки.

Блокировка, ограничивающая манипуляции со страницей данных в таблице (набор строк, объединённый признаком совместного хранения) иногда называется страничной (англ. page locking).

Предикатная блокировка действует на область, ограниченную предикатом. Обычно это блокировка по диапазону ключей. При такой блокировке для ключа или индекса указывается значение или диапазон значений, на которые распространяется блокировка. Такая блокировка (а также блокировка всей таблицы), помимо прочего, защищает от чтения фантомов и обеспечивает уровень изоляции транзакции Serializable.

По строгости Совместная блокировка накладывается транзакцией на объект в случае, если выполняемая ей операция безопасна, то есть не изменяет никаких данных и не имеет побочных эффектов. При этом, все транзакции могут выполнять операцию того же типа над объектом, если на него наложена совместная блокировка, обычно такая блокировка используется для операций чтения.

Исключительная блокировка накладывается транзакцией на объект в случае, если выполняемая ей операция изменяет данные. Только одна транзакция может выполнять подобную операцию над объектом, если на него наложена исключительная блокировка. Блокировка не может быть наложена на объект, если на него уже наложена совместная блокировка.

По логике реализации Пессимистическая блокировка накладывается перед предполагаемой модификацией данных на все строки, которые такая модификация предположительно затрагивает. Во время действия такой блокировки исключена модификация данных из сторонних сессий, данные из блокированных строк доступны согласно уровню изолированности транзакции. По завершению предполагаемой модификации гарантируется непротиворечивая запись результатов.

Оптимистическая блокировка не ограничивает модификацию обрабатываемых данных сторонними сессиями, однако перед началом предполагаемой модификации запрашивает значение некоторого выделенного атрибута каждой из строк данных (обычно используется наименование VERSION и целочисленный тип с начальным значением 0). Перед записью модификаций в базу данных перепроверяется значение выделенного атрибута, и если оно изменилось, то транзакция откатывается или применяются различные схемы разрешения коллизий. Если значение выделенного атрибута не изменилось — производится фиксация модификаций с одновременным изменением значения выделенного атрибута (например, инкрементом) для сигнализации другим сессиям о том, что данные изменились.


pg_lock

Представление pg_locks даёт доступ к информации о блокировках, удерживаемых активными процессами на сервере баз данных.

Представление pg_locks содержит одну строку для каждого активного блокируемого объекта, запрошенного режима блокировки и блокирующего процесса. Таким образом, один и тот же блокируемый объект может фигурировать в этом представлении неоднократно, если его блокируют или ожидают блокировки несколько процессов. Однако объекты, свободные от блокировок, в этом представлении отсутствуют вовсе.

Существует несколько различных типов блокируемых объектов: отношения целиком (например, таблицы), отдельные страницы отношений, отдельные кортежи отношений, идентификаторы транзакций (виртуальные и постоянные) и произвольные объекты баз данных (идентифицируемые по OID класса и OID объекта, так же как в pg_description или pg_depend). Кроме того, в виде отдельного блокируемого объекта представлено право расширения отношения, как и право изменения значения pg_database.datfrozenxid. Также могут быть установлены «рекомендательные» блокировки, не имеющие предопределённого значения.

Имя
Тип
Ссылки
Описание
locktype
text

Тип блокируемого объекта: relation (отношение), extend (расширение отношения), frozenid (замороженный идентификатор), page (страница), tuple (кортеж), transactionid (идентификатор транзакции), virtualxid (виртуальный идентификатор), object (объект), userlock (пользовательская блокировка) или advisory (рекомендательная)
database
oid
pg_database.oid
OID базы данных, к которой относится цель блокировки, ноль, если это разделяемый объект, либо NULL, если целью является идентификатор транзакции
relation
oid
pg_class.oid
OID отношения, являющегося целью блокировки, либо NULL, если цель блокировки — не отношение или часть отношения
page
integer

Номер страницы в отношении, являющейся целью блокировки, либо NULL, если цель блокировки — не страница или кортеж отношения
tuple
smallint

Номер кортежа на странице, являющегося целью блокировки, либо NULL, если цель блокировки — не кортеж
virtualxid
text

Виртуальный идентификатор транзакции, являющийся целью блокировки, либо NULL, если цель блокировки — другой объект
transactionid
xid

Идентификатор транзакции, являющийся целью блокировки, либо NULL, если цель блокировки — другой объект
classid
oid
pg_class.oid
OID системного каталога, содержащего цель блокировки, либо NULL, если цель блокировки — не обычный объект базы данных
objid
oid
любой столбец OID
OID цели блокировки в соответствующем системном каталоге, либо NULL, если цель блокировки — не обычный объект базы данных
objsubid
smallint

Номер столбца, являющегося целью блокировки (на саму таблицу указывают classid и objid), ноль, если это некоторый другой обычный объект базы данных, либо NULL, если цель не обычный объект
virtualtransaction
text

Виртуальный идентификатор транзакции, удерживающей или ожидающей блокировку
pid
integer

Идентификатор серверного процесса (PID, Process ID), удерживающего или ожидающего эту блокировку, либо NULL, если блокировка удерживается подготовленной транзакцией
mode
text

Название режима блокировки, которая удерживается или запрашивается этим процессом (см. Подраздел 13.3.1 и Подраздел 13.2.3)
granted
boolean

True, если блокировка получена, и false, если она ожидается
fastpath
boolean

True, если блокировка получена по короткому пути, и false, если она получена через основную таблицу блокировок

Transaction ID

ID транзакции на которой удерживается блокировка


MVCC

Для того, чтобы каждый пользователь видел согласованное стостояние базы данных, постгрес использует механизм управления конкурентным доступом с помощью многоверсионности MVCC (Multi Version Concurrency Control).


pg_stats_activity

pg_stat_activity ещё одно интересное представление (view) из pg_catalog’а. Оно показывает запросы выполняющиеся в данный момент


Изоляция транзакций

Стандарт SQL определяет четыре уровня изоляции транзакций. Наиболее строгий из них — сериализуемый, определяется одним абзацем, говорящем, что при параллельном выполнении несколько сериализуемых транзакций должны гарантированно выдавать такой же результат, как если бы они запускались по очереди в некотором порядке. Остальные три уровня определяются через описания особых явлений, которые возможны при взаимодействии параллельных транзакций, но не допускаются на определённом уровне. Как отмечается в стандарте, из определения сериализуемого уровня вытекает, что на этом уровне ни одно из этих явлений не возможно. (В самом деле — если эффект транзакций должен быть тем же, что и при их выполнении по очереди, как можно было бы увидеть особые явления, связанные с другими транзакциями?)

Стандарт описывает следующие особые условия, недопустимые для различных уровней изоляции:

«грязное» чтение Транзакция читает данные, записанные параллельной незавершённой транзакцией.

неповторяемое чтение Транзакция повторно читает те же данные, что и раньше, и обнаруживает, что они были изменены другой транзакцией (которая завершилась после первого чтения).

фантомное чтение Транзакция повторно выполняет запрос, возвращающий набор строк для некоторого условия, и обнаруживает, что набор строк, удовлетворяющих условию, изменился из-за транзакции, завершившейся за это время.

аномалия сериализации Результат успешной фиксации группы транзакций оказывается несогласованным при всевозможных вариантах исполнения этих транзакций по очереди.


Уровни изоляции

Уровень изоляции
«Грязное» чтение
Неповторяемое чтение
Фантомное чтение
Аномалия сериализации
Read uncommited (Чтение незафиксированных данных)
Допускается, но не в PG
Возможно
Возможно
Возможно
Read committed (Чтение зафиксированных данных)
Невозможно
Возможно
Возможно
Возможно
Repeatable read (Повторяемое чтение)
Невозможно
Невозможно
Допускается, но не в PG
Возможно
Serializable (Сериализуемость)
Невозможно
Невозможно
Невозможно
Невозможно
В Postgres Pro вы можете запросить любой из четырёх уровней изоляции транзакций, однако внутри реализованы только три различных уровня, то есть режим Read Uncommitted в Postgres Pro действует как Read Committed. Причина этого в том, что только так можно сопоставить стандартные уровни изоляции с реализованной в Postgres Pro архитектурой многоверсионного управления конкурентным доступом.

READ COMMITTED Оператор видит только те строки, которые были зафиксированы до начала его выполнения. Этот уровень устанавливается по умолчанию.

REPEATABLE READ Все операторы текущей транзакции видят только те строки, которые были зафиксированы перед первым запросом на выборку или изменение данных, выполненным в этой транзакции.

SERIALIZABLE Все операторы текущей транзакции видят только те строки, которые были зафиксированы перед первым запросом на выборку или изменение данных, выполненным в этой транзакции. Если наложение операций чтения и записи параллельных сериализуемых транзакций может привести к ситуации, невозможной при последовательном их выполнении (когда одна транзакция выполняется за другой), произойдёт откат одной из транзакций с ошибкой serialization_failure (сбой сериализации).

Грязное чтение



Как установить уровень изоляции транзакции

```
begin
set transaction isolation level [SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED ]
select * from orders;
...
commit;

```

Внутренние вложенные транзакции

Точки сохранения

В SQL определены точки сохранения (savepoint), которые позволяют отменить часть операцией транзакции, не прерывая ее полностью. Но это не укладывается в приведенную выше схему, поскольку статус у транзакции один на все ее изменения, а физически никакие данные не откатываются.

Чтобы реализовать такой функционал, транзакция с точкой сохранения разбивается на несколько отдельных вложенных транзакций (subtransaction), статусом которых можно управлять отдельно.

Вложенные транзакции имеют свой собственный номер (бóльший, чем номер основной транзакции). Статус вложенных транзакций записывается обычным образом в XACT, однако финальный статус зависит от статуса основной транзакции: если она отменена, то отменяются также и все вложенные транзакции.

Информация о вложенности транзакций хранится в файлах в каталоге PGDATA/pg_subtrans. Обращение к файлам происходит через буферы в общей памяти экземпляра, организованные так же, как и буферы XACT.

Не путайте вложенные транзакции и автономные транзакции. Автономные транзакции никак не зависят друг от друга, а вложенные — зависят. Автономных транзакций в обычном PostgreSQL нет, и, пожалуй, к лучшему: по делу они нужны очень и очень редко, а их наличие в других СУБД провоцирует злоупотребление, от которого потом все страдают. NB Автономная транзакция — это независимая транзакция, запускаемая внутри родительской транзакции. В отличие от подтранзакций, которые могут фиксироваться только вместе с транзакцией, к которой они относятся, автономные транзакции должны фиксироваться или отменяться до завершения их родительской транзакции. Тогда как подтранзакции применяются для обработки ошибок и в хранимых процедурах, автономные подтранзакции нужны в первую очередь для реализации аудита, когда факт попытки выполнения транзакции должен быть зафиксирован независимо от того, была ли эта транзакция завершена успешно.

Очистим таблицу, начнем транзакцию и вставим строку:

```
=> TRUNCATE TABLE t;
=> BEGIN;
=> INSERT INTO t(s) VALUES ('FOO');
=> SELECT txid_current();
 txid_current 
--------------
         3669
(1 row)

=> SELECT xmin, xmax, * FROM t;
 xmin | xmax | id |  s  
------+------+----+-----
 3669 |    0 |  2 | FOO
(1 row)

=> SELECT * FROM heap_page('t',0);
 ctid  | state  | xmin | xmax  | t_ctid 
-------+--------+------+-------+--------
 (0,1) | normal | 3669 | 0 (a) | (0,1)
(1 row)

```
Теперь поставим точку сохранения и вставим еще одну строку.

```
=> SAVEPOINT sp;
=> INSERT INTO t(s) VALUES ('XYZ');
=> SELECT txid_current();
 txid_current 
--------------
         3669
(1 row)

```
Заметьте, что функция txid_current() выдает номер основной, а не вложенной, транзакции.

```
=> SELECT xmin, xmax, * FROM t;
 xmin | xmax | id |  s  
------+------+----+-----
 3669 |    0 |  2 | FOO
 3670 |    0 |  3 | XYZ
(2 rows)

=> SELECT * FROM heap_page('t',0);
 ctid  | state  | xmin | xmax  | t_ctid 
-------+--------+------+-------+--------
 (0,1) | normal | 3669 | 0 (a) | (0,1)
 (0,2) | normal | 3670 | 0 (a) | (0,2)
(2 rows)

```
Откатимся к точке сохранения и вставим третью строку.

```
=> ROLLBACK TO sp;
=> INSERT INTO t(s) VALUES ('BAR');
=> SELECT xmin, xmax, * FROM t;
 xmin | xmax | id |  s  
------+------+----+-----
 3669 |    0 |  2 | FOO
 3671 |    0 |  4 | BAR
(2 rows)

=> SELECT * FROM heap_page('t',0);
 ctid  | state  |   xmin   | xmax  | t_ctid 
-------+--------+----------+-------+--------
 (0,1) | normal | 3669     | 0 (a) | (0,1)
 (0,2) | normal | 3670 (a) | 0 (a) | (0,2)
 (0,3) | normal | 3671     | 0 (a) | (0,3)
(3 rows)

```
В странице мы продолжаем видеть строку, добавленную отмененной вложенной транзакцией.

Фиксируем изменения.

```
=> COMMIT;
=> SELECT xmin, xmax, * FROM t;
 xmin | xmax | id |  s  
------+------+----+-----
 3669 |    0 |  2 | FOO
 3671 |    0 |  4 | BAR
(2 rows)

=> SELECT * FROM heap_page('t',0);
 ctid  | state  |   xmin   | xmax  | t_ctid 
-------+--------+----------+-------+--------
 (0,1) | normal | 3669 (c) | 0 (a) | (0,1)
 (0,2) | normal | 3670 (a) | 0 (a) | (0,2)
 (0,3) | normal | 3671 (c) | 0 (a) | (0,3)
(3 rows)

```
Теперь хорошо видно, что каждая вложенная транзакция имеет собственный статус.

Заметим, что вложенные транзакции нельзя использовать в SQL явно, то есть нельзя начать новую транзакцию, не завершив текущую. Этот механизм задействуется неявно при использовании точек сохранения, а еще при обработке исключений PL/pgSQL и в ряде других, более экзотических, случаев.

```
=> BEGIN;
BEGIN
=> BEGIN;
WARNING:  there is already a transaction in progress
BEGIN
=> COMMIT;
COMMIT
=> COMMIT;
WARNING:  there is no transaction in progress
COMMIT

```

Установить таймаут на транзакцию

```
BEGIN;
SET LOCAL lock_timeout = '4s';
SELECT ....;
COMMIT;

```

Эскалация блокировок

Например, таблица состоит из страниц, которые содержат табличные строки. Все эти объекты могут выступать в качестве ресурсов. Если процессы обычно заинтересованы всего в нескольких строках, а блокировка устанавливается на уровне таблицы, то другие процессы не смогут одновременно работать с разными строками. Поэтому чем выше гранулярность, тем лучше для возможности распараллеливания.

Но это приводит к увеличению числа блокировок (информацию о которых надо хранить в памяти). В таком случае может применяться повышение уровня (эскалация) блокировок: когда количество низкоуровневых, высокогранулярных блокировок превышает определенный предел, они заменяются на одну блокировку более высокого уровня.


Явная блокировка

```
LOCK [ TABLE ] [ ONLY ] имя [ * ] [, ...] [ IN режим_блокировки MODE ] [ NOWAIT ]

Где режим_блокировки может быть следующим:

    ACCESS SHARE | ROW SHARE | ROW EXCLUSIVE | SHARE UPDATE EXCLUSIVE
    | SHARE | SHARE ROW EXCLUSIVE | EXCLUSIVE | ACCESS EXCLUSIVE

```
Описание LOCK TABLE получает блокировку на уровне таблицы, при необходимости ожидая освобождения таблицы от других конфликтующих блокировок. Если указано NOWAIT, LOCK TABLE не ждёт, пока таблица освободится: если блокировку нельзя получить немедленно, команда прерывается и выдаётся ошибка. Как только блокировка получена, она удерживается до завершения текущей транзакции. (Команды UNLOCK TABLE не существует; блокировки всегда освобождаются в конце транзакции.)

Запрашивая автоматические блокировки для команд, работающих с таблицами, Postgres Pro всегда выбирает наименее ограничивающий режим блокировки из возможных. Оператор LOCK TABLE предназначен для случаев, когда требуется более сильная блокировка. Например, предположим, что приложение выполняет транзакцию на уровне изоляции READ COMMITTED и оно должно получать неизменные данные на протяжении всей транзакции. Для достижения этой цели можно получить для таблицы блокировку в режиме SHARE, прежде чем обращаться к ней. В результате параллельные изменения данных будут исключены и при последующих чтениях будет получено стабильное представление зафиксированных данных, так как режим блокировки SHARE конфликтует с блокировкой ROW EXCLUSIVE, запрашиваемой при записи, а LOCK TABLE имя IN SHARE MODE будет ждать, пока параллельные транзакции с блокировкой ROW EXCLUSIVE не будут зафиксированы или отменены. Таким образом, в момент получения такой блокировки не останется ни одной открытой незафиксированной операции записи; кроме того, никто не сможет записывать в таблицу, пока блокировка не будет снята.

Чтобы получить похожий эффект в транзакции на уровне изоляции REPEATABLE READ или SERIALIZABLE, необходимо выполнить оператор LOCK TABLE перед первым SELECT или оператором, изменяющим данные. Представление данных для транзакции уровня REPEATABLE READ или SERIALIZABLE будет заморожено в момент, когда начнёт выполняться этот запрос. Если команда LOCK TABLE выполняется в транзакции позже, она так же исключает параллельную запись, но не даёт гарантии, что транзакция будет читать последние зафиксированные данные.

Если в транзакции такого рода требуется изменять данные в таблице, для неё следует использовать режим блокировки SHARE ROW EXCLUSIVE вместо SHARE. Этот режим гарантирует, что в один момент времени будет выполняться только одна транзакция такого типа. Без этого ограничения возможна взаимоблокировка: две транзакции могут одновременно получить блокировки SHARE, после чего они не смогут получить блокировку ROW EXCLUSIVE, чтобы собственно выполнить изменения. (Заметьте, что собственные блокировки транзакции никогда не конфликтуют, так что транзакция может получить блокировку ROW EXCLUSIVE, когда она владеет блокировкой SHARE — но не тогда, когда блокировку SHARE удерживает другая транзакция.) Чтобы не допустить взаимоблокировок, убедитесь, что все транзакции запрашивают блокировки одних объектов в одинаковом порядке, и если для одного объекта запрашиваются блокировки в разных режимах, транзакции всегда должны запрашивать самую строгую блокировку.

Пример Получение блокировки SHARE для первичного ключа таблицы при добавлении записи в подчинённую таблицу:

```
BEGIN WORK;
LOCK TABLE films IN SHARE MODE;
SELECT id FROM films
    WHERE name = 'Star Wars: Episode I - The Phantom Menace';
-- Если запись не будет возвращена, произойдёт откат транзакции
INSERT INTO films_user_comments VALUES
    (_id_, 'GREAT! I was waiting for it for so long!');
COMMIT WORK;

```
Установление блокировки SHARE ROW EXCLUSIVE в таблице первичного ключа перед выполнением операции удаления:

```
BEGIN WORK;
LOCK TABLE films IN SHARE ROW EXCLUSIVE MODE;
DELETE FROM films_user_comments WHERE id IN
    (SELECT id FROM films WHERE rating < 5);
DELETE FROM films WHERE rating < 5;
COMMIT WORK;

```

Замечания

1. Временные таблицы не удаляются а переиспользуются
2. Транзакция и её выполнение (невыполнение) никак не влияет на контекст внутри которого она исполняется (переменные, процедуры).
3. Проброс таблиц из одной бд в другую осуществляется при помощи посотоянного соединения foreign_data_wrapper

# Вопросы

- Что такое транзакция? Пример. Открытие, закрытие, откат.
- Что такое точки сохранения?
- Что такое ACID? Каким свойствам должны удовлетворять транзакции?
Атомарность;
Согласованность;
Изолированность;
Устойчивость;

- Уровни изоляции;
- Что такое фантомное чтение? В какой ситуации это происходит, пример.
**Фантомное чтение (phantom read) — ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка даёт разные множества строк**
Это происходит следующим образом: одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по одним и тем же критериям. В интервалах между этими выборками другая транзакция добавляет строки или изменяет столбцы некоторых строк, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества строк.

- Что такое фантомная запись?
**Фантомная запись — это аномалия, которая возникает в том случае, когда одна и та же транзакция пытается повторно считать данные из какой-то таблицы, но между двумя этими считываниями какая-то другая транзакция занесла изменения в эту таблицу**. В таком случае при повторном чтении появляются новые данные, которых не было ранее.

- В каких случаях использовать разные уровни изоляции? 
**Read commited** - для большинства случаев;
**Repeatable read**
Вот несколько примеров применения уровня изоляции Repeatable Read в PostgreSQL:

- **Обеспечение стабильности данных**. Режим Repeatable Read гарантирует, что каждая транзакция видит полностью стабильное представление базы данных. 
- **Последовательное чтение данных**. Последовательные команды SELECT в одной транзакции видят одни и те же данные.
- **Применение бизнес-правил**. Даже транзакция только для чтения на этом уровне может видеть обновлённую контрольную запись, которая показывает, что пакет был завершён, но не видеть одну из детальных записей, которая логически является частью пакета, потому что она прочитала более раннюю ревизию контрольной записи. 

**SERIALIZABLE** (Сериализуемость). Самый строгий уровень изоляции. Транзакции выполняются так, как если бы они выполнялись последовательно. Это предотвращает «грязное чтение», «неповторяющееся чтение» и «фантомные» записи. Однако это может привести к блокировкам и ухудшению производительности

Важно помнить, что выбор уровня изоляции зависит от конкретных требований приложения и ожидаемых характеристик работы с данными.


- Пример с параллельными транзакциями (изолированность). Блокировки;
![](images/Pasted%20image%2020240603162740.png)
- Что такое блокировка? Классификация блокировок. Какие системные таблицы отвечают за блокировки?
- Что такое эскалация блокировок?
- Что нельзя выполнять в транзакции? (удаление схем, БД, системные таблицы, переименование, vacuum, autovacuum, reindex);
- Особенности работы с pgsql, clickhouse? Есть ли транзакции в clickhouse;
- Плюсы/минусы транзакций?
- Как в SQLAlchemy выглядить транзакции, как их использовать транзакции, как с ними выполнять основные операции?
- Какая максимальная вложенность транзакций? 
- Особенности работы транзакций в  переменных, процедурах?
Транзакция и её выполнение (невыполнение) никак не влияет на контекст внутри которого она исполняется (переменные, процедуры).
# Источники
- https://postgrespro.ru/docs/postgrespro/10/tutorial-transactions (официальная документация PostgresPro);
