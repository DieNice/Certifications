# Создание итератора
1. Определение итератора. Зачем нужны итераторы?
   >[!Ответ]-
   Итераторы позволяют вам сделать поочередно перебрать элементы, которые будут вычисляется по мере их поступления. Использование итератора вместо списка list, набора set или другой итерируемой структуры данных может иногда позволить нам сэкономить память. Например, мы можем использовать itertools.repeat, чтобы создать итерируемый объект с большим количество элементов:

2. Как создать итератор в стиле ООП
>[!Ответ]-
>```Python
>class SimpleIterator:
>    def __init__(self, limit):
>        self.limit = limit
>        self.counter = 0
>
>    def __next__(self):
>        if self.counter < self.limit:
>            self.counter += 1
>            return 1
>        else:
>            raise StopIteration
>
>	s_iter1 = SimpleIterator(3)
>	print(next(s_iter1))
>	print(next(s_iter1))
>	print(next(s_iter1))
>	print(next(s_iter1))
>```


3. Перечислите основные отличия между итератором и итерабельным объектом.  
>[!Ответ]-
> Оба объекта позволяют перебирать коллекции, но их внутренняя логика разнится. Основные отличия приведены ниже.  
>   
> **Итератор**  
> 
> 1. По мере перебора истощается
> 2. При повторном обращении продолжает перебор с последнего места остановки
> 3. Не индексируется
> 4. Для повторного перебора с начала нужно пересоздавать
> 5. Занимает мало места в памяти
> 
> Итераторы создаются, например, функциями **map()**, **zip()**.
> 
> **Итерабельный объект**  
> 
> 1. Никогда не истощается
> 2. При повторном обращении в другом месте программы начинает перебирать элементы с начала
> 3. Индексируется
> 4. Не требует пересоздания для повторной итерации
> 5. Занимает больше места в памяти
> 
> Итерабельными объектами являются списки, кортежи.

4. Приведите несколько примеров встроенных функций-итераторов, используемых в Питоне.  

Итераторы используются достаточно часто, так как практически не тратят память компьютера. Именно поэтому в Питон встроено большое количество соответствующих функций. Вот некоторые из них:  
  
**open()** – для работы с файлами;  
**zip()** – формирует итератор кортежей из представленных последовательностей;  
**map()** – модифицирует каждый элемент итерируемого объекта.  
  
Чтобы проверить, является ли объект итератором, достаточно сравнить его с с самим собой, обернутым в функцию **iter()**.

5. Когда применяются ленивые вычисления и в чём из логика?
Ленивые вычисления предполагают, что не нужно ничего делать до тех пор, пока в этом нет необходимости. Так, если мы не обратились к свойству класса (которое определяется некими математическими операциями, например), то не нужно заранее его рассчитывать. На этом базируется, в том числе, логика генераторов. Многие итераторы также являются ленивыми. Это не просто удобно, но позволяет экономить память и время на вычисление.
Функция **range()** – ленивая. Она заранее не формирует последовательность из гигантского количества чисел. А когда мы обращаемся к некому ее элементу по индексу (это разрешено, так как она создает итерабельный объект), он выводится почти сразу.  
  
Если вы рискнете преобразовать этот массив чисел в список, то случится одно из двух: либо выведется ошибка о нехватке памяти на компьютере, либо очень-очень долго будет формироваться список всех объектов.

6. Как пишется typehint?
7. Как работает вхождение в генератор?
# Создание генератора

1. Определение генератора

Генератор — это функция, которая возвращает итерируемый объект (такой, как список или кортеж). Вместо того, чтобы возвращать все элементы сразу, генератор возвращает элементы по одному по мере необходимости.

2. Создание генератора
```Python
def simple_generator(val):
   while val > 0:
       val -= 1
       yield 1

gen_iter = simple_generator(5)
print(next(gen_iter))
print(next(gen_iter))
print(next(gen_iter))
print(next(gen_iter))
print(next(gen_iter))
print(next(gen_iter))
```
3. Для чего используется ключевое слово yield
Ключевое слово «yield» используется для создания генераторов. Генератор — это функция, которая может возвращать последовательность значений используя инструкции yield вместо return. При каждом вызове инструкции yield генератор возвращает значение, после чего сохраняет свое состояние и приостанавливает свое выполнение до следующего вызова. Это позволяет генерировать последовательности значений без необходимости создания и хранения всех значений в памяти, что может быть особенно полезно при работе с большими объемами данных. Кроме того, генераторы являются итерируемыми и могут использоваться в циклах for.
4. Что будет напечатано в результате выполнения следующего кода
```Python
def f_g():
    yield 43
    return 66

    print(f_g())
```

Результат выполнения кода будет объект генератора (generator object). Когда мы вызываем функцию с yield, то это создает генератор, который возвращает объект-итератор. Так как print(f_g()) вызывает только генератор, а не запускает его выполнение, то мы получим объект-итератор в качестве результата, а не значение, возвращенное посредством yield или return. Если мы хотим получить значение из генератора, мы должны использовать ключевое слово next, чтобы продвинуть генератор на следующее значение или использовать цикл for для извлечения всех значений из итератора. Вот пример вызова генератора с помощью цикла for:
```Python
def f_g():
    yield 43
    return 66
for i in f_g():
    print(i)
```
Этот код выведет только 43, потому что выполнение генератора останавливается после первого вызова yield.

5. Как перевернуть генератор?
```Python
my_list = [1, 2, 3, 4, 5]
my_generator = (x**2 for x in my_list)

for item in reversed(tuple(my_generator)):
    print(item)
```
6.  Как пишется typehint
7. yield from
8. Дополнительные методы генератора (send, close)?
9. Как работает вхождение в итератор?
# Отличие итератора и генератора
Основное отличие генераторов от итераторов заключается в том, как они создаются. Итераторы требуют больше кода и больше понимания протокола итератора. Генераторы же позволяют создать итератор более простым и удобным способом.

В общем, итераторы и генераторы обеспечивают удобный способ работы с коллекциями данных в Python. Они позволяют перебирать элементы коллекций, не загружая все элементы в память одновременно, что делает их очень эффективными для работы с большими наборами данных.

# Функции next и iter

Любой объект в Питоне становится итератором только тогда, когда в него внедрен соответствующий протокол. Он включает 2 метода:

– iter() – возвращает сам себя, вызывается в самом начале. Позволяет пользоваться циклом for и выражением in»;
– next() – перебирает коллекцию по одному элементу и вызывает ошибку StopIteration, когда их не остается.

Пример – Интерактивный режим
---
```Python
>>> num_lst = [7, 10, 3]
>>> num_lst_iter = iter(num_lst)
>>> next(num_lst_iter)
7
>>> next(num_lst_iter)
10
>>> next(num_lst_iter)
3
>>> next(num_lst_iter)
StopIteration
```

Обозначенную последовательность чисел мы превратили в итератор с помощью функции iter(). После того как функция next() перебрала все значения, возникла ошибка StopIteration

---
# Задачи
## Итератор-повторятор

Создайте функцию **infinite(lst, tries)**, которая будет проходиться по элементам списка **lst** (целые числа) заданное количество раз (**tries**) циклически. Один раз - один элемент списка. После вывода последнего значения последовательности процедура начнется с самого начала.  
  
Например, если в списке 2 элемента, а функция получила значение 3, то сначала выведется первый объект, потом последний, а потом опять первый. Результат работы функции представьте в виде строки, состоящей из **tries** количества символов.
>[!Ответ]- 
>```Python
>from itertools import cycle
> 
 >
>def infinite(lst, iterations):
>    result = ''
>    iter_lst = cycle(lst)
>    if lst:
>        for symbol in range(iterations):
>            result += str(next(iter_lst))
>    return result
 >
># Тесты
>print(infinite([2, 5, 8], 7))
>print(infinite([], 1000))
>print(infinite([7], 4))
> ```

## Генератор-дискриминатор

Написать функцию-генератор выводящий все символы строки на печать только если они являются буквами.

>[!answer]-
>```Python
>def show_letters(some_str):
>	yield from ''.join([letter for letter in some_str if letter.isalpha()])
> 
> 
>random_str = show_letters('A!sdf 09 _ w')
>print(next(random_str))
>print(next(random_str))
>```

---
# Ссылки
1. https://stepik.org/lesson/24464/step/1?unit=6769
2. https://smartiqa.ru/python-workbook

#Аттестация