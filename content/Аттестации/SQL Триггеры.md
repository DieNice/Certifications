Триггерные функции могут быть написаны на большинстве доступных процедурных языков PL/pgSQL, PL/Python, PL/Tcl.
# Обзор механизма работы триггеров
**Триггер** - это механизм, который указывает что база данных должна автоматически выполнить заданную функцию, всякий раз когда выполнен определенный тип операции. Если происходит событие триггера, для обработки этого события в установленный момент времени вызывается функция триггера;
Триггеры можно использовать с таблицами (секционированными и обычными), с представлениями и внешними таблицами.
Для обычных и внешних таблиц можно определить триггеры, который будут срабатывать до или после INSERT, UPDATE или DELETE.

Для **представлений** триггеры могут быть определены для выполнения вместо операции insert, update или delete. Такие триггеры вызываются только для каждой строки, которая должна быть изменена в представлении.

## Создание триггера
- Триггерная функция должна быть создана до создания триггера;
- Триггерная функция объявляется без аргументов (триггерная функция получается данные через контекст TriggerData);
- Триггерная функция возвращает специальный тип trigger (фактически record);
- Триггерная функция может использоваться для нескольких триггеров;
- В определении триггера можно указать **WHEN** чтобы наложить условие запуска триггера; 
- **INSTEAD OF** не поддерживает **WHEN**

```postgresql
CREATE [ CONSTRAINT ] TRIGGER _`имя`_ { BEFORE | AFTER | INSTEAD OF } { _`событие`_ [ OR ... ] }
    ON _`имя_таблицы`_
    [ FROM _`ссылающаяся_таблица`_ ]
    [ NOT DEFERRABLE | [ DEFERRABLE ] [ INITIALLY IMMEDIATE | INITIALLY DEFERRED ] ]
    [ FOR [ EACH ] { ROW | STATEMENT } ]
    [ WHEN ( _`условие`_ ) ]
    EXECUTE PROCEDURE _`имя_функции`_ ( _`аргументы`_ )

Здесь допускается _`событие`_:

    INSERT
    UPDATE [ OF _`имя_столбца`_ [, ... ] ]
    DELETE
    TRUNCATE
```

>[!tip] Для UPDATE можно указать триггер на изменение определенных столбцов.

>[!tip] Триггер может также срабатывать на TRUNCATE

# Типы триггеров
Триггеры бывают **построчные (триггер уровня строк)** и **операторные (триггер уровня оператора)**.
В случае построчного триггера триггерная функция вызывается каждый раз для каждой строки, затронутой оператором;
Триггерные функции, вызываемые триггерами строк, могут вернуть строку таблицы.

Операторный триггер вызывает один раз триггерную функцию для оператора запустившего ее, независимо от количества строк (даже 0).
Триггерные функции, вызываемые триггерами операторов, должны всегда возвращать NULL.

>[!warning] Триггер может срабатывать для каждой модифицируемой строки либо один раз для оператора SQL

**Классификация триггеров:**
- Срабатывают ДО (*BEFORE*);
- Срабатывают ПОСЛЕ (*AFTER*);
- Срабатывают ВМЕСТО (*INSTEAD OF*);

>[!info] Для операций INSERT и UPDATE (и только для них) триггер может изменить строку NEW перед тем как её вернуть. В результате будут изменены данные, возвращаемые INSERT RETURNING или UPDATE RETURNING, что полезно, когда представление должно возвращать не те данные, что были получены.

>[!info] Если есть несколько триггеров на одно и то же событие для одной и той же таблицы, то они будут вызываться в алфавитном порядке по имени триггера. 


## BEFORE

## AFTER

## INSTEAD OF

Такие триггеры могут определяться только для представлений и только на уровне строк.

**Триггерная функция** — это обычная функция, которая написана с учетом некоторых соглашений:
* она пишется на любом языке, кроме чистого SQL;
* она не имеет параметров;
* она возвращает значение типа trigger (на самом деле это псевдотип, по факту возвращается запись, соответствующая строке таблицы;

>[!danger] Триггерная функция выполняется в той же транзакции, что и основная операция. Таким образом, если триггерная функция завершится с ошибкой, вся транзакция будет прервана.

>[!info] Если триггерная функция выполняет команды SQL, эти команды могут заново запускать триггеры.
Это известно как каскадные триггеры. 

## События

![](../images/Pasted%20image%2020240314001519.png)
>[!danger] INSTEAD OF
 instead-of-триггеры можно определить только для представлений на уровне строк, а truncate-триггер можно определить только для таблиц и только на уровне оператора. Видимость изменений в данных.

# Видимость изменений в данных

- Триггеры уровня оператора следуют простым правилам видимости: никакие из изменений, произведённых оператором, не видны в триггерах BEFORE, тогда как в триггерах AFTER видны все изменения.
- Изменение данных (вставка, обновление или удаление), заставляющее сработать триггер, не видно для команд SQL, выполняемых в триггере BEFORE уровня строки, потому что это изменение ещё не произошло.
- Тем не менее команды SQL, выполняемые в триггере BEFORE уровня строки, будут видеть изменения данных в строках, которые уже были обработаны в этом операторе. Это требует осторожности, так как порядок обработки строк в целом непредсказуемый; команда SQL, обрабатывающая множество строк, может делать это в любом порядке.
- Аналогично, триггер INSTEAD OF уровня строки увидит изменения данных, внесённые при предыдущих вызовах триггера INSTEAD OF для этой же внешней команды.
- Когда срабатывает триггер AFTER уровня строки, все изменения сделанные оператором уже
выполнены и видны в вызываемой триггерной функции.
# Пример триггера

```postgresql
=> CREATE OR REPLACE FUNCTION history_insert() RETURNS trigger
AS $$
BEGIN
    EXECUTE format(
        'INSERT INTO %I SELECT ($1).*, current_timestamp, NULL',
        TG_TABLE_NAME||'_history'
    ) USING NEW;

    RETURN NEW;
END
$$ LANGUAGE plpgsql;

CREATE FUNCTION

Другая функция будет закрывать интервал действия исторической строки:

=> CREATE OR REPLACE FUNCTION history_delete() RETURNS trigger
AS $$
BEGIN
    EXECUTE format(
        'UPDATE %I SET end_date = current_timestamp WHERE face_value = $1 AND end_date IS NULL',
        TG_TABLE_NAME||'_history'
    ) USING OLD.face_value;

    RETURN OLD;
END
$$ LANGUAGE plpgsql;


=> CREATE TRIGGER coins_history_insert
AFTER INSERT OR UPDATE ON coins
FOR EACH ROW EXECUTE FUNCTION history_insert();

CREATE TRIGGER

=> CREATE TRIGGER coins_history_delete
AFTER UPDATE OR DELETE ON coins
FOR EACH ROW EXECUTE FUNCTION history_delete();

CREATE TRIGGER
```

```Postgresql
CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    EXECUTE PROCEDURE check_account_update();
```

```Postgresql
CREATE TRIGGER check_update
    BEFORE UPDATE OF balance ON accounts
    FOR EACH ROW
    EXECUTE PROCEDURE check_account_update();
```

```POSTGRESQL
CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.balance IS DISTINCT FROM NEW.balance)
    EXECUTE PROCEDURE check_account_update();
```

# Примеры использования
Как правило, триггеры BEFORE уровня строки используются для проверки или модификации данных, которые будут вставлены или изменены. Например, триггер BEFORE можно использовать для вставки текущего времени в столбец timestamp или проверки, что два элемента строки согласованы между собой.
Триггеры AFTER уровня строки наиболее разумно использовать для каскадного обновления данных в других таблицах или проверки согласованности сделанных изменений с данными в других таблицах.

 Причина для такого разделения работы в том, что триггер AFTER видит окончательное значение строки, в то время как для триггера BEFORE это не так, ведь могут быть другие триггеры BEFORE, которые сработают позже. Если нет особых причин для выбора между триггерами BEFORE или AFTER, то триггер BEFORE предпочтительнее, так как не требует сохранения информации об операции до конца работы оператора.

# Событийные триггеры
Триггеры срабатывающие на DDL операции (CREATE, ALTER,DROP и т.д.) по своей сути большей необходимые для задач администрирования.

# Дополнительно

## Truncate и Триггеры

`TRUNCATE` действует только для таблиц и только на уровне операции before/after statement.
Кроме того, можно сузить область действия триггера, указав дополнительное условие WHEN: если условие не выполняется — триггер не срабатывает

Поскольку триггерная функция не имеет параметров, контекст вызова
в PL/pgSQL передается ей с помощью предопределенных TG-переменных, таких, как:
TG_WHEN = «BEFORE»,
TG_LEVEL = «STATEMENT»,
TG_OP = «INSERT»/«UPDATE»/«DELETE»/«TRUNCATE»

## NEW_TABLE, OLD_TABLE для триггеров на уровне операции

В PostgreSQL, `NEW_TABLE` и `OLD_TABLE` не являются стандартными переменными, доступными в триггерах на уровне строк. Вместо этого, в контексте триггеров, обычно используются переменные `NEW` и `OLD`, которые представляют новые и старые значения строки соответственно. Эти переменные доступны только в триггерах на уровне строки (row-level triggers), где каждая строка, затронутая операцией INSERT, UPDATE или DELETE, вызывает триггер.
В триггерах на уровне операции (statement-level triggers), `NEW` и `OLD` не доступны, поскольку эти триггеры не имеют доступа к отдельным строкам, затронутым операцией. Они вызываются один раз для каждой операции, независимо от количества затронутых строк.
Вместо этого, в триггерах на уровне операции, можно использовать специальные переменные `NEW_TABLE` и `OLD_TABLE` для доступа к набору строк, затронутых операцией.

Пример использования `NEW_TABLE` и `OLD_TABLE` в триггере на уровне операции:
**Создание таблицы**
```postgresql
CREATE TABLE public.test (
    number integer NOT NULL,
    text   character varying(50)
);
```

**Триггерная функция:**
```postgresql
CREATE OR REPLACE FUNCTION public.tr_test_for_each_statement()
   RETURNS trigger
   LANGUAGE plpgsql
AS
$$
DECLARE
    x_rec record;
BEGIN
    RAISE NOTICE '=operation: % =', TG_OP;
    IF (TG_OP = 'UPDATE' OR TG_OP = 'DELETE') THEN
        FOR x_rec IN SELECT * FROM OLD_TABLE LOOP
            RAISE NOTICE 'OLD: %', x_rec;
        END LOOP;
    END IF;
    IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
        FOR x_rec IN SELECT * FROM NEW_TABLE LOOP
            RAISE NOTICE 'NEW: %', x_rec;
        END LOOP;
    END IF;

    RETURN NULL;
END;
$$;

```

**Триггеры уровня оператора**
```postgresql
CREATE TRIGGER tr_test_for_each_statement_insert
   AFTER INSERT ON public.test
   REFERENCING NEW TABLE AS new_table
   FOR EACH STATEMENT
   EXECUTE PROCEDURE public.tr_test_for_each_statement();

CREATE TRIGGER tr_test_for_each_statement_update
   AFTER UPDATE ON public.test
   REFERENCING NEW TABLE AS new_table OLD TABLE AS old_table
   FOR EACH STATEMENT
   EXECUTE PROCEDURE public.tr_test_for_each_statement();

CREATE TRIGGER tr_test_for_each_statement_delete
   AFTER DELETE ON public.test
   REFERENCING OLD TABLE AS old_table
   FOR EACH STATEMENT
   EXECUTE PROCEDURE public.tr_test_for_each_statement();
```
**Примеры использования:**
```postgresql
INSERT INTO public.test(number, text) VALUES (1, 'a');
=operation: INSERT =
NEW: (1,a)

INSERT INTO public.test(number, text) VALUES (2, 'b'),  (3, 'b');
=operation: INSERT =
NEW: (2,b)
NEW: (3,b)

UPDATE public.test SET number = number + 1 WHERE text = 'a';
=operation: UPDATE =
OLD: (1,a)
NEW: (2,a)

UPDATE public.test SET number = number + 10 WHERE text = 'b';
=operation: UPDATE =
OLD: (2,b)
OLD: (3,b)
NEW: (12,b)
NEW: (13,b)

DELETE FROM public.test;
=operation: DELETE =
OLD: (2,a)
OLD: (12,b)
OLD: (13,b)
```

### Важные моменты

- `NEW_TABLE` и `OLD_TABLE` доступны только в триггерах на уровне операции и представляют собой наборы строк, затронутых операцией.
- В триггерах на уровне строки, `NEW` и `OLD` используются для доступа к новым и старым значениям отдельных строк.
- Функция триггера должна возвращать либо `NULL`, либо запись/строку, имеющую точно такое же структуру, как и таблица, для которой был вызван триггеры.

Использование `NEW_TABLE` и `OLD_TABLE` в триггерах на уровне операции позволяет более гибко обрабатывать множественные строки в рамках одной операции, что может быть полезно для реализации сложных бизнес-логик или аудита изменений данных.

## Ограничения на Триггеры

В PostgreSQL существуют определенные ограничения и особенности при работе с триггерами, которые следует учитывать:
1. **Типы триггеров**: PostgreSQL поддерживает триггеры на уровне строки (FOR EACH ROW) и на уровне оператора (FOR EACH STATEMENT). Триггеры на уровне строки вызываются для каждой строки, затронутой операцией, в то время как триггеры на уровне оператора вызываются один раз для каждой операции, независимо от количества затронутых строк. Триггеры на TRUNCATE могут быть определены только на уровне оператора [1](https://www.postgresql.org/docs/current/trigger-definition.html).
2. **Классификация триггеров**: Триггеры классифицируются по типу их срабатывания: BEFORE, AFTER и INSTEAD OF. BEFORE триггеры срабатывают до выполнения операции, AFTER триггеры срабатывают после выполнения операции, а INSTEAD OF триггеры срабатывают вместо операции. INSTEAD OF триггеры могут быть определены только на представлениях и только на уровне строки.
3. **Производительность и масштабируемость**: Производительность и масштабируемость триггеров зависят от типа триггера, языка триггера и действий, выполняемых триггером. Простые триггеры PL/PgSQL, которые не выполняют никаких действий, имеют практически нулевую нагрузку. Триггеры FOR EACH ROW имеют более высокую нагрузку, чем FOR EACH STATEMENT триггеры. AFTER триггеры более дорогие, чем BEFORE триггеры, поскольку они должны быть ожидаемыми до завершения операции, а затем выполнены.
4. **Каскадные триггеры**: Если функция триггера выполняет SQL команды, которые могут снова вызвать триггеры, это известно как каскадные триггеры. Нет прямого ограничения на количество уровней каскада. Возможно, каскады могут вызвать рекурсивное вызовы одного и того же триггера, поэтому от разработчика триггера требуется избегать бесконечной рекурсии в таких сценариях.
5. **Ограничения на использование**: Для создания триггера на таблице пользователь должен иметь привилегию TRIGGER на таблице и EXECUTE на функцию триггера. Если создано несколько триггеров на один объект для одного события, они будут вызваны в алфавитном порядке по имени .
6. **Ограничения на CHECK constraints**: PostgreSQL не поддерживает CHECK ограничения, которые ссылаются на данные других строк или таблиц. Это означает, что CHECK ограничение, которое нарушает это правило, может казаться работающим в простых тестах, но не может гарантировать, что база данных не достигнет состояния, в котором условие ограничения будет ложным (из-за последующих изменений других строк или таблиц). Это может привести к сбою при восстановлении данных из дампа.
7. **Использование триггеров для обеспечения ограничений**: В случае, когда требуется однокрачная проверка данных по отношению к другим строкам при вставке, вместо постоянного обеспечения согласованности, можно использовать пользовательский триггер для реализации этого. Этот подход позволяет избежать проблем с восстановлением данных из дампа, поскольку триггеры не восстанавливаются до окончания восстановления данных.
8. **Транзакционность**: Важно отметить, что выполнение AFTER триггера может быть отложено до конца транзакции, а не до конца операции, если он был определен как триггер ограничения (constraint trigger). Это означает, что если операция или триггер вызывает ошибку, эффекты обеих будут откатываться

## Триггеры для создания ограничений (constrainsts).
В PostgreSQL, триггеры могут быть использованы для реализации ограничений (constraints), которые не могут быть напрямую реализованы с помощью стандартных ограничений CHECK, FOREIGN KEY, UNIQUE и других. Это особенно актуально для случаев, когда требуется проверка условий, зависящих от данных в других строках или таблицах, что не поддерживается стандартными ограничениями из-за их предположения о неизменности условий.

### Ограничения и особенности
- **Неизменность условий**: PostgreSQL предполагает, что условия CHECK константны, то есть они всегда дают одинаковый результат для одной и той же строки. Это оправдание для проверки ограничений только при вставке или обновлении строк, а не в других случаях.
- **Ограничения на ссылку на данные**: PostgreSQL не поддерживает CHECK ограничения, которые ссылаются на данные других строк или таблиц. Это означает, что ограничение, нарушающее это правило, может казаться работающим в простых тестах, но не может гарантировать, что база данных не достигнет состояния, в котором условие ограничения будет ложным (из-за последующих изменений других строк или таблиц).
- **Использование триггеров для однократной проверки**: Если требуется однократная проверка данных по отношению к другим строкам при вставке, вместо постоянного обеспечения согласованности, можно использовать пользовательский триггер для реализации этого. Этот подход позволяет избежать проблем с восстановлением данных из дампа, поскольку триггеры не восстанавливаются до окончания восстановления данных

Пример создания триггера для реализации ограничения:
```postgresql
CREATE FUNCTION check_sex() RETURNS trigger
   LANGUAGE plpgsql AS
$$BEGIN
   IF dam NOT IN (SELECT sheep_id
       FROM sheep
       WHERE sex='f'
      )
   THEN
      RAISE EXCEPTION 'only females can be dams';
   END IF;
 
   RETURN dam;
END;$$;

CREATE TRIGGER sex_trigger_f BEFORE INSERT OR UPDATE ON sheep FOR EACH ROW EXECUTE FUNCTION check_sex();

```

Этот пример демонстрирует, как можно использовать триггер для реализации ограничения, которое не может быть выражено с помощью стандартного ограничения CHECK.

## Особенность триггеров на уровне строк для секционированных таблиц

Особенностью триггеров на уровне строк для секционированных таблиц в PostgreSQL является то, что они не могут быть напрямую применены к самой секционированной таблице. Это связано с тем, что проверка существования секции (partition) осуществляется до выполнения операции INSERT и, следовательно, до того, как может быть вызван триггер. В результате, попытка создать триггер на уровне строки для секционированной таблицы приведет к ошибке.
Однако, начиная с PostgreSQL 13, введены изменения, позволяющие использовать триггеры на уровне строк для секционированных таблиц. Если триггер создается на основной секционированной таблице, он автоматически распространяется на все существующие секции. Это означает, что если вы добавляете новую секцию к секционированной таблице, триггер будет автоматически создан и применен к этой новой секции. Это поведение обеспечивает большую гибкость при работе с секционированными таблицами, позволяя применять одинаковые триггеры к каждой секции без необходимости вручную создавать их для каждой секции.
Пример создания триггера на основной секционированной таблице, который будет автоматически распространяться на все секции:

```postgresql
CREATE TRIGGER proper_fullname BEFORE INSERT OR UPDATE ON users FOR EACH ROW EXECUTE FUNCTION proper_fullname();`
```

В этом примере, если таблица `users` является секционированной, триггер `proper_fullname` будет автоматически применен ко всем секциям этой таблицы. Это упрощает управление триггерами в секционированных таблицах, особенно когда требуется применять одинаковые триггеры к каждой секции [2](https://www.depesz.com/2020/03/31/waiting-for-postgresql-13-enable-before-row-level-triggers-for-partitioned-tables/).

Таким образом, важно учитывать эту особенность при работе с секционированными таблицами в PostgreSQL, особенно при использовании версий до PostgreSQL 13, где прямое применение триггеров на уровне строк к секционированным таблицам не поддерживается.

Триггеры на уровне строк для секционированных таблиц в PostgreSQL имеют несколько ограничений и особенностей:
1. **Ограничения на использование**: Попытка создать триггер на уровне строк для секционированной таблицы приведет к ошибке, поскольку PostgreSQL не поддерживает триггеры на уровне строк для секционированных таблиц напрямую. Это связано с тем, что проверка существования секции осуществляется до выполнения операции INSERT, и, следовательно, до того, как может быть вызван триггер.
2. **Изменение секции**: BEFORE ROW триггеры на INSERT не могут изменить, какая секция будет конечным местом для новой строки. Это означает, что логика триггера не может влиять на выбор секции для вставки данных.
3. **Смешивание временных и постоянных отношений**: В одном дереве секционирования не допускается смешивание временных и постоянных отношений. Если основная секционированная таблица является постоянной, то и все ее секции должны быть постоянными, и наоборот. При использовании временных отношений все члены дерева секционирования должны принадлежать к одной и той же сессии.
4. **Ограничения на наследование**: Секции не могут иметь родителей, отличных от секционированной таблицы, от которой они являются секцией. Таблица не может наследовать от секционированной таблицы и от обычной таблицы одновременно. Это означает, что секционированные таблицы и их секции никогда не делят иерархию наследования с обычными таблицами.
5. **Ограничения на ограничения**: Невозможно создать ограничение исключения, охватывающее всю секционированную таблицу. Такое ограничение можно установить только на каждую конечную секцию индивидуально. Это ограничение связано с тем, что невозможно обеспечить ограничения между разными секциями.
6. **Ограничения на уникальные и первичные ключи**: Для создания уникального или первичного ключа на секционированной таблице ключи секционирования не должны включать выражения или вызовы функций, и столбцы ограничения должны включать все столбцы ключа секционирования. Это ограничение существует, поскольку индивидуальные индексы, составляющие ограничение, могут обеспечивать уникальность только в пределах своей секции.
Эти ограничения и особенности важны для понимания того, как работают триггеры на уровне строк в контексте секционированных таблиц в PostgreSQL, и как они могут быть использованы или ограничены в зависимости от конкретных требований к базе данных.
# Источники
[^1]: Документация к PostgreSQL 16.1 The PostgreSQL Global Development Group "Постгрес Профессиональный" (Глава 39);
[^2]: https://postgrespro.ru/education/courses/DEV1
[^3]: https://edu.postgrespro.ru/16/dev1-16/dev1_17_plpgsql_triggers.html
[^4]:  https://postgrespro.ru/docs/postgresql/9.6/sql-createtrigger
[^5]: https://www.postgresql.org/docs/current/plpgsql-trigger.html
[^6]: https://www.postgresql.org/docs/current/sql-createtrigger.html
