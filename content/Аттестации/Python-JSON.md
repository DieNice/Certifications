---
date: 2024-04-18
author: Проскурин Д.А
tags:
  - Аттестация
  - Python
---
![|400](images/Pasted%20image%2020231031203616.png)
JSON (Java Script Object Notation) - текстовый формат обмена данными, основанный на JavaScript. Как и многие другие текстовые форматы, JSON легко читается людьми.

# Использование

Основное использование JSON это сериализация объектов данных.
За счёт своей лаконичности по сравнению с XML формат JSON может быть более подходящим для сериализации сложных структур. Применяется в веб-приложениях как для обмена данными между браузером и сервером (AJAX), так и между серверами (программные HTTP-сопряжения).

# Синтаксис

JSON-текст представляет собой (в закодированном виде) одну из двух структур:
- Набор пар ключ: значение. В различных языках это реализовано как запись, структура, словарь, хеш-таблица, список с ключом или ассоциативный массив. Ключом может быть только строка (регистрозависимость не регулируется стандартом, это остаётся на усмотрение программного обеспечения. Как правило, регистр учитывается программами — имена с буквами в разных регистрах считаются разными, например[5]), значением — любая форма. Повторяющиеся имена ключей допустимы, но не рекомендуются стандартом; обработка таких ситуаций происходит на усмотрение программного обеспечения, возможные варианты — учитывать только первый такой ключ, учитывать только последний такой ключ, генерировать ошибку.
- Упорядоченный набор значений. Во многих языках это реализовано как массив, вектор, список или последовательность.
Структуры данных, используемые JSON, поддерживаются любым современным языком программирования, что и позволяет применять JSON для обмена данными между различными языками программирования и программными системами.
В качестве значений в JSON могут быть использованы:
- запись — это неупорядоченное множество пар ключ:значение, заключённое в фигурные скобки «{ }». Ключ описывается строкой, между ним и значением стоит символ «:». Пары ключ-значение отделяются друг от друга запятыми.
- массив (одномерный) — это упорядоченное множество значений. Массив заключается в квадратные скобки «[ ]». Значения разделяются запятыми. Массив может быть пустым, то есть не содержать ни одного значения. Значения в пределах одного массива могут иметь разный тип.
- число (целое или вещественное).
- литералы true (логическое значение «истина»), false (логическое значение «ложь») и null.
- строка — это упорядоченное множество из нуля или более символов юникода, заключённое в двойные кавычки. Символы могут быть указаны с использованием escape-последовательностей, начинающихся с обратной косой черты «\» (поддерживаются варианты \", \\, \/, \t, \n, \r, \f и \b), или записаны шестнадцатеричным кодом в кодировке Unicode в виде \uFFFF.
Пример
```json
{
   "firstName": "Иван",
   "lastName": "Иванов",
   "address": {
       "streetAddress": "Московское ш., 101, кв.101",
       "city": "Ленинград",
       "postalCode": 101101
   },
   "phoneNumbers": [
       "812 123-1234",
       "916 123-4567"
   ]
}
```


# Сравнение с YAML


Как функционально, так и синтаксически JSON является подмножеством языка YAML. В частности, спецификация YAML 1.2 указывает, что «любой файл в формате JSON является корректным файлом в формате YAML». Наиболее распространённый парсер YAML способен обрабатывать и JSON. 
Наиболее важным отличием YAML является набор расширений синтаксиса, которым нет аналогов в JSON:

- поддержка реляционных данных: в YAML-документе можно ссылаться на якорь, встретившийся ранее в файле/потоке; таким образом можно выразить рекурсивные структуры.
- поддержка расширяемых типов данных помимо примитивов: строк, чисел, логических значений и т. д.
- поддержка блочного синтаксиса с отступами; он позволяет описать структурированные данные без использования лишних символов: всевозможных скобок, кавычек и т. д
Цели создания:

Согласно целям, озвученным Кларком Эвансом (англ. Clark Evans), YAML 1.0 призван[7]:

1. быть понятным человеку;
2. поддерживать структуры данных, родственные для языков программирования;
3. быть переносимым между языками программирования;
4. использовать цельную модель данных для поддержки обычного инструментария;
5. поддерживать потоковую обработку;
6. быть выразительным и расширяемым;
7. быть лёгким в реализации и использовании;

Последовательности (списки)

```yml
 --- # Список фильмов: последовательность в блочном формате
 - Casablanca
 - Spellbound
 - Notorious
 --- # Список покупок: последовательность в однострочном формате
 [milk, bread, eggs, juice]
```

Сопоставления имени и значения (словари)

```yaml
 --- # Блочный формат
 name: John Smith
 age: 33
 --- # Однострочный формат
 {name: John Smith, age: 33}
```

Сопоставления из последовательностей

```yml
 men: [John Smith, Bill Jones]
 women:
   - Mary Smith
   - Susan Williams
```

```yaml
bindings:
  - ircEvent: PRIVMSG
    method: newUri
    regexp: '^http://.*'
  - ircEvent: PRIVMSG
    method: deleteUri
    regexp: '^delete.*'
  - ircEvent: PRIVMSG
    method: randomUri
    regexp: '^random.*'
```

или

```yml
bindings: 
  - {ircEvent: PRIVMSG, method: newUri, regexp: '^http://.*'}
  - {ircEvent: PRIVMSG, method: deleteUri, regexp: '^delete.*'}
  - {ircEvent: PRIVMSG, method: randomUri, regexp: '^random.*'}
```
Пример преобразования
```json
{"store": {
    "book": [
        {"category": "reference",
         "author": "Nigel Rees",
         "title": "Sayings of the Century",
         "price": 8.95
         },
        {"category": "fiction",
            "author": "Evelyn Waugh",
            "title": "Sword of Honour",
            "price": 12.99
         },
        {"category": "fiction",
            "author": "Herman Melville",
            "title": "Moby Dick",
            "isbn": "0-553-21311-3",
            "price": 8.99
         },
        {"category": "fiction",
            "author": "J. R. R. Tolkien",
            "title": "The Lord of the Rings",
            "isbn": "0-395-19395-8",
            "price": 22.99
         }
    ],
    "bicycle": {
        "color": "red",
        "price": 19.95
    }
}
}
```
в
```yml
store: 
 book: 
  - 
   category: reference
   author: "Nigel Rees"
   title: "Sayings of the Century"
   price: 8.95
  - 
   category: fiction
   author: "Evelyn Waugh"
   title: "Sword of Honour"
   price: 12.99
  - 
   category: fiction
   author: "Herman Melville"
   title: "Moby Dick"
   isbn: "0-553-21311-3"
   price: 8.99
  - 
   category: fiction
   author: "J. R. R. Tolkien"
   title: "The Lord of the Rings"
   isbn: "0-395-19395-8"
   price: 22.99
 bicycle: 
  color: red
  price: 19.95
```


# Вопросы безопасности

Хотя JSON предназначен для передачи данных в сериализованном виде, его синтаксис соответствует синтаксису JavaScript и это создаёт ряд проблем безопасности. Зачастую для обработки данных, полученных от внешнего источника в формате JSON, к ним применяется функция eval() без какой-либо предварительной проверки.

Другие "подформаты" JSON
JSONP и JSONPP;  JSONB

JSON encoder and decoder

Есть 2 способа реализовать сериализацию и десериализацию для пользовательских объектов в JSON.
1 способ - написать функцию. Пример ниже
```Python
>>> import json
>>> def as_complex(dct):
...     if '__complex__' in dct:
...         return complex(dct['real'], dct['imag'])
...     return dct
...
>>> json.loads('{"__complex__": true, "real": 1, "imag": 2}',
...     object_hook=as_complex)
(1+2j)
>>> import decimal
>>> json.loads('1.1', parse_float=decimal.Decimal)
Decimal('1.1')
```
2 способ - расширение базового класса с переопределением метода этого класса
```
>>> import json
>>> class ComplexEncoder(json.JSONEncoder):
...     def default(self, obj):
...         if isinstance(obj, complex):
...             return [obj.real, obj.imag]
...         # Let the base class default method raise the TypeError
...         return json.JSONEncoder.default(self, obj)
...
>>> json.dumps(2 + 1j, cls=ComplexEncoder)
'[2.0, 1.0]'
>>> ComplexEncoder().encode(2 + 1j)
'[2.0, 1.0]'
>>> list(ComplexEncoder().iterencode(2 + 1j))
['[2.0', ', 1.0', ']']
```

# XPATH (JsonPath)


JSONPath — это язык запросов для JSON, похожий на XPath для XML. Как и XPath, JSONPath позволяет извлекать данные из структуры JSON и фильтровать их. В json больших json файлах со сложной структурой jsonpath очень сильно помогает

|XPath|JSONPath|Result|
|---|---|---|
|`/store/book/author`|`$.`[store.book](http://store.book)`[*].author`|the authors of all books in the store|
|`//author`|`$..author`|all authors|
|`/store/*`|`$.store.*`|all things in store, which are some books and a red bicycle.|
|`/store//price`|`$.store..price`|the price of everything in the store.|
|`//book[3]`|`$..book[2]`|the third book|
|`//book[last()]`|`$..book[(@.length-1)]`<br><br>  <br><br>`$..book[-1:]`|the last book in order.|
|`//book[position()<3]`|`$..book[0,1]`<br><br>  <br><br>`$..book[:2]`|the first two books|
|`//book[isbn]`|`$..book[?(@.isbn)]`|filter all books with isbn number|
|`//book[price<10]`|`$..book[?(@.price<10)]`|filter all books cheapier than 10|
|`//*`|`$..*`|all Elements in XML document. All members of JSON data item.|

Для работы с jsonpath есть хорошая библиотека jsonpath-ng
```json
import json
from jsonpath_ng import jsonpath
from jsonpath_ng.ext import parse

data = '''{"store": {
    "book": [
        {"category": "reference",
         "author": "Nigel Rees",
         "title": "Sayings of the Century",
         "price": 8.95
         },
        {"category": "fiction",
            "author": "Evelyn Waugh",
            "title": "Sword of Honour",
            "price": 12.99
         },
        {"category": "fiction",
            "author": "Herman Melville",
            "title": "Moby Dick",
            "isbn": "0-553-21311-3",
            "price": 8.99
         },
        {"category": "fiction",
            "author": "J. R. R. Tolkien",
            "title": "The Lord of the Rings",
            "isbn": "0-395-19395-8",
            "price": 22.99
         }
    ],
    "bicycle": {
        "color": "red",
        "price": 19.95
    }
}
}'''


if __name__ == '__main__':
    data_json = json.loads(data)
    jsonpath_expression = parse("$.*.book[3].[price,title]")
    jsonpath_expression = parse("$..book[?(@.isbn)]")
    jsonpath_expression = parse("$..book[?(@.price < 10)]")
    match = jsonpath_expression.find(data_json)
    print([(i.value) for i in match])
```


---

### JSON
1. **Вопрос**: Какой формат даты для JSON чаще всего используется? Типы данных json. Что такое сериализация/десириализация. Как сериализовать кастомный объект?
    **Ответ**: в JSON чаще всего используется _ISO_ формат

2. **Вопрос**: Есть ли в JSON ограничение на уровень вложенности объектов?
    **Ответ**: В python по умолчанию ограничением является 100 вложений, однако его можно увеличить при помощи аргумента `dephs` в `json.dump`, `json.dumps`. Поэтому по сути - ограничения задаются либами для работы с JSON. У самого JSON такого ограничения нет.
    **Интересный факт**: пока проверял инфу - удалось создать dict с максимальной вложенностью (у меня ругалось на макс. вложенность при 1493 вложении)

3. **Вопрос**: Есть ли ограничения у JSON?
   **Ответ:** По сути все ограничения JSON связаны с железом, кроме типов данных. JSON не умеет сам работать с кастомными типами данных, с типом даты, UUID и т.д. Однако, все это обходится с помощью кастомных сериализаторов.

4. **Вопрос:** Какие есть библиотеки для работы с JSON?
   **Ответ:** json,
   orjson - для скоростной работы с json,
   tortillia - для обертки запроса api и превращения ответа в формат json 
   jsonpickle - позволяет сериализовать объекты в формат json
   jsondiff - нужен для поиска различий между json файлами

5. **Вопрос:** Pydantic и JSON:
   **Ответ:** На данный момент для анализа json данных используется `from_json` из `pydantic_core`. С помощью этой функции pydantic сам получает необходимые поля из json и анализирует их. Если в JSON есть список, а модель поддерживает только `tuple`, то pydantic автоматически приведет список к tuple. Эта функция принимает 2 аргумента (`value: str, allow_patrial: bool`)
   Первый аргумент - наш JSON, второй - флаг, который разрешает или запрещает использовать частичный JSON.
   >[!tip]+ Пример использования:
   >```python
   >from pydantic_core import from_json
   >from pydantic import BaseModel
   >
   >class Dog(BaseModel):
   >	breed: str
   >	name: str
   >	friends: list
   >	
   >partial_dog_json = '{"breed": "lab", "name": "fluffy", "friends": ["buddy", "spot", "rufus"], "age'
   >dog = Dog.model_validate(from_json(partial_dog_json, allow_partial=True))
   >print(repr(dog))
   >#> Dog(breed='lab', name='fluffy', friends=['buddy', 'spot', 'rufus'])
   >```

6. **Вопрос:** Где используется JSON?
   **Ответ:** По большей части JSON используется для обмена данных между сервисами (особенно в API), но вообще его можно использовать почти где угодно. Даже для хранения данных в БД.

7. **Вопрос:** что такое JSONPath?
   **Ответ:** JSONPath - это язык запросов, аналогичный XPath. Для работы с JSONPath в Python используют `jsonpath-ng` библиотеку.

8. **Вопрос:** Работа с JSON в postgresql. Тип данных, операции jsonpath
   **Ответ:** для работы с JSON и JSONB в opstgresql используется:
   - `jsonb_path_exists`(value, jsonpath) - содержится ли шаблон в json
   - `jsonb_path_match`(value, jsonpath) - выполняет поиск значений, которые соответствуют шаблону jsonpath
   - `jsonb_path_query`(value, jsonpath) - используется для запросов к json с использованием jsonpath (*основная операция для работы с jsonpath*)
   - `jsonb_path_query_array`(value, jsonpath) - возвращает массив значений, соответствующих шаблону jsonpath
   - `jsonb_path_query_first`(value, jsonpath) - возвращает первое значение, соответствующее шаблону jsonpath
   основные операции в jsonpath:
   `$` - Это текущий контекст json элемента. То есть по сути - при помощи этой операции мы обозначаем область для обработки json.
   `?` - Позволяет указать фильтр (эта операция аналогична `WHERE`)
   `@` - Текущий контекст в выражении фильтра. То есть сначала мы указываем область обработки при помощи `$`, а далее уже используем `@` для фильтрации:
   Пример: `$[*] ? (@ > 3)`
   `[]` - обозначение массива
   `*` - знак, обозначающий любой элемент

9. **Вопрос:** Когда JSON нужно использовать в БД?
   **Ответ:** JSON используют в бд тогда, когда сигнатура хранимых данных постоянно меняется. Соответственно, вместо того, что бы постоянно менять структуру таблицы - проще хранить данные в формате JSON, где не важно, какой структуры данные там хранятся.

### XML
1. **Вопрос:** Что такое XML? Где он используется? Чем он отличается от JSON? Чем он хуже JSON?
   **Ответ:** XML - тоже язык текстовой разметки. Ранее использовался почти везде, но позже все перешли на JSON, так как его удобнее читать + он меньше весит за счет более компактного синтаксиса.
   На данный момент он часто используется в 1С + его можно встретить при работе с excel файлами.

2. **Вопрос:** библиотеки для работы с XML
   **Ответ:** lxml, xml, defusedxml (проверяет xml на безопасность)

3. **Вопрос:** Что такое XPATH?
   **Ответ:** XPath - это язык запросов, необходимый для поиска данных внутри XML

4. **Вопрос:** Кейсы использования XPath для python разработчика
   **Ответ:** Основным кейсом для использования XPath является парсинг данных. Как в явном виде - так и в неявном(используя либы по типу `BeautifulSoup`).

### YAML
1. **Вопрос:** Можно ли писать в YAML в стиле JSON?
   **Ответ:** Да можно. В YAML файле можно все написать на JSON.

2. **Вопрос:** Что такое якоря в YAML?
   **Ответ:** Якоря в YAML - это ссылки на существующие сущности, которые можно переиспользовать. Объявляется якорь через `<поле>: &<название якоря>`, а использовать его можно через `<<: *<название якоря>`.

3. **Вопрос:** Где применяется YAML?
   **Ответ:** YAML применяется в SWAGGER, конфигурациях, манифестах.

4. **Вопрос:** Методы для сериализации YAML
   **Ответ:** метод dump в yaml сам сериализует объекты (а точнее их поля) в yaml. Это работает даже в том случае, если поле объекта является объектом.
   При такой сериализации тэг в YAML документе будет иметь следующий вид: `python/object:__main__.Person`, однако этот тэг можно поменять следующим образом:
   >[!code]+
   >```python
   >class Person(yaml.YAMLObject):
   >	yaml_tag = "Person"
   >	...
   >```
   
   в этом случае тэг в YAML документе будет иметь значение свойства `yaml_tag`.
   Для сериализации используется `safe_load`:
   >[!code]+
   >```python
   >person = yaml.safe_load(yaml_obj, Loader=yaml.Loader)
   >```


5. **Вопрос:** Опасный метод load. Почему от него отказались?
   **Ответ:** От метода load отказались, так как в нем можно было передавать исполняемый код, что создавало серьезную уязвимость. Сейчас же вместо `load` используют `safe_load`, который не позволяет передавать в себе исполняемый код.